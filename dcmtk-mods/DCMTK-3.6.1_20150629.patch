diff --git a/CMake/GenerateDCMTKConfigure.cmake b/CMake/GenerateDCMTKConfigure.cmake
index bbb4f25..b0db75d 100644
--- a/CMake/GenerateDCMTKConfigure.cmake
+++ b/CMake/GenerateDCMTKConfigure.cmake
@@ -249,12 +249,12 @@ ENDIF(WIN32 AND NOT CYGWIN)
   CHECK_FUNCTION_EXISTS(gethostbyname_r HAVE_GETHOSTBYNAME_R)
   CHECK_FUNCTION_EXISTS(gethostbyaddr_r HAVE_GETHOSTBYADDR_R)
   CHECK_FUNCTION_EXISTS(getgrnam_r HAVE_GETGRNAM_R)
-  CHECK_FUNCTION_EXISTS(getpwnam_r HAVE_GETPWNAM_R)
+  CHECK_SYMBOL_EXISTS(getpwnam_r pwd.h HAVE_GETPWNAM_R)
   CHECK_FUNCTION_EXISTS(gethostname HAVE_GETHOSTNAME)
   CHECK_FUNCTION_EXISTS(gethostid HAVE_GETHOSTID)
-  CHECK_FUNCTION_EXISTS(getlogin HAVE_GETLOGIN)
+  CHECK_SYMBOL_EXISTS(getlogin pwd.h HAVE_GETLOGIN)
   CHECK_FUNCTION_EXISTS(getpid HAVE_GETPID)
-  CHECK_FUNCTION_EXISTS(getpwnam HAVE_GETPWNAM)
+  CHECK_SYMBOL_EXISTS(getpwnam pwd.h HAVE_GETPWNAM)
   CHECK_FUNCTION_EXISTS(getsockname HAVE_GETSOCKNAME)
   CHECK_FUNCTION_EXISTS(getsockopt HAVE_GETSOCKOPT)
   CHECK_FUNCTION_EXISTS(getuid HAVE_GETUID)
@@ -498,11 +498,6 @@ ENDIF(WIN32 AND NOT CYGWIN)
   CHECK_FUNCTIONWITHHEADER_EXISTS("popen" "${HEADERS}" HAVE_POPEN)
   CHECK_FUNCTIONWITHHEADER_EXISTS("pclose" "${HEADERS}" HAVE_PCLOSE)
 
-IF(DCMTK_WITH_OPENSSL)
-  # Check if OpenSSL provides the SSL_CTX_get0_param function
-  CHECK_FUNCTIONWITHHEADER_EXISTS("SSL_CTX_get0_param" "openssl/ssl.h" HAVE_SSL_CTX_GET0_PARAM ${OPENSSL_LIBS})
-ENDIF(DCMTK_WITH_OPENSSL)
-
 # Tests that require a try-compile
 INCLUDE(${DCMTK_CMAKE_INCLUDE}CMake/dcmtkTryCompile.cmake)
 INCLUDE(${DCMTK_CMAKE_INCLUDE}CMake/dcmtkTryRun.cmake)
@@ -764,7 +759,7 @@ FUNCTION(INSPECT_FUNDAMENTAL_ARITHMETIC_TYPES)
     COMPILE_DEFINITIONS -I"${DCMTK_BINARY_DIR}/config/include" -I"${DCMTK_SOURCE_DIR}/ofstd/include"
     RUN_OUTPUT_VARIABLE OUTPUT
     COMPILE_OUTPUT_VARIABLE CERR
-    ARGS \"${ARITH_H_FILE}\"
+    ARGS ${ARITH_H_FILE}
   )
   IF(COMPILED)
     IF(NOT RESULT)
diff --git a/CMake/android.toolchain.cmake b/CMake/android.toolchain.cmake
index 94f7da4..89905c8 100644
--- a/CMake/android.toolchain.cmake
+++ b/CMake/android.toolchain.cmake
@@ -1,26 +1,3 @@
-#
-#
-#  Copyright (C) 2015, OFFIS e.V.
-#  All rights reserved.  See COPYRIGHT file for details.
-#
-#  This software and supporting documentation were developed by
-#
-#    OFFIS e.V.
-#    R&D Division Health
-#    Escherweg 2
-#    D-26121 Oldenburg, Germany
-#
-#  Author:  Jan Schlamelcher
-#
-#  Purpose:
-#      Detecting and inspecting any available Android NDK installation
-#      and contained toolchains. Setting the depending CMake variables
-#      appropriately based on the detection results and user settings.
-#
-#  This file is based upon this Android toolchain file found on
-#  github: https://github.com/taka-no-me/android-cmake,
-#  originally released under this license:
-
 # Copyright (c) 2010-2011, Ethan Rublee
 # Copyright (c) 2011-2014, Andrey Kamaev
 # All rights reserved.
@@ -52,13 +29,10 @@
 # POSSIBILITY OF SUCH DAMAGE.
 
 # ------------------------------------------------------------------------------
-#  Android CMake toolchain file, for use with the Android NDK r5-r9
+#  Android CMake toolchain file, for use with the Android NDK r5-r10c
 #  Requires cmake 2.6.3 or newer (2.8.5 or newer is recommended).
 #  See home page: https://github.com/taka-no-me/android-cmake
 #
-#  The file is maintained by the OpenCV project. The latest version can be get at
-#  http://code.opencv.org/projects/opencv/repository/revisions/master/changes/android/android.toolchain.cmake
-#
 #  Usage Linux:
 #   $ export ANDROID_NDK=/absolute/path/to/the/android-ndk
 #   $ mkdir build && cd build
@@ -73,7 +47,7 @@
 #
 #  Usage Windows:
 #     You need native port of make to build your project.
-#     Android NDK r7 (or newer) already has make.exe on board.
+#     Android NDK r7 (and newer) already has make.exe on board.
 #     For older NDK you have to install it separately.
 #     For example, this one: http://gnuwin32.sourceforge.net/packages/make.htm
 #
@@ -99,36 +73,54 @@
 #      used by ndk-build tool from Android NDK.
 #
 #      Possible targets are:
-#        "armeabi" - matches to the NDK ABI with the same name.
-#           See ${ANDROID_NDK}/docs/CPU-ARCH-ABIS.html for the documentation.
-#        "armeabi-v7a" - matches to the NDK ABI with the same name.
-#           See ${ANDROID_NDK}/docs/CPU-ARCH-ABIS.html for the documentation.
+#        "armeabi" - ARMv5TE based CPU with software floating point operations
+#        "armeabi-v7a" - ARMv7 based devices with hardware FPU instructions
+#            this ABI target is used by default
 #        "armeabi-v7a with NEON" - same as armeabi-v7a, but
 #            sets NEON as floating-point unit
 #        "armeabi-v7a with VFPV3" - same as armeabi-v7a, but
-#            sets VFPV3 as floating-point unit (has 32 registers instead of 16).
-#        "armeabi-v6 with VFP" - tuned for ARMv6 processors having VFP.
-#        "x86" - matches to the NDK ABI with the same name.
-#            See ${ANDROID_NDK}/docs/CPU-ARCH-ABIS.html for the documentation.
-#        "mips" - matches to the NDK ABI with the same name.
-#            See ${ANDROID_NDK}/docs/CPU-ARCH-ABIS.html for the documentation.
+#            sets VFPV3 as floating-point unit (has 32 registers instead of 16)
+#        "armeabi-v6 with VFP" - tuned for ARMv6 processors having VFP
+#        "x86" - IA-32 instruction set
+#        "mips" - MIPS32 instruction set
+#
+#      64-bit ABIs for NDK r10 and newer:
+#        "arm64-v8a" - ARMv8 AArch64 instruction set
+#        "x86_64" - Intel64 instruction set (r1)
+#        "mips64" - MIPS64 instruction set (r6)
 #
 #    ANDROID_NATIVE_API_LEVEL=android-8 - level of Android API compile for.
 #      Option is read-only when standalone toolchain is used.
+#      Note: building for "android-L" requires explicit configuration.
 #
-#    ANDROID_TOOLCHAIN_NAME=arm-linux-androideabi-4.6 - the name of compiler
+#    ANDROID_TOOLCHAIN_NAME=arm-linux-androideabi-4.9 - the name of compiler
 #      toolchain to be used. The list of possible values depends on the NDK
-#      version. For NDK r8c the possible values are:
+#      version. For NDK r10c the possible values are:
 #
-#        * arm-linux-androideabi-4.4.3
+#        * aarch64-linux-android-4.9
+#        * aarch64-linux-android-clang3.4
+#        * aarch64-linux-android-clang3.5
 #        * arm-linux-androideabi-4.6
-#        * arm-linux-androideabi-clang3.1
-#        * mipsel-linux-android-4.4.3
+#        * arm-linux-androideabi-4.8
+#        * arm-linux-androideabi-4.9 (default)
+#        * arm-linux-androideabi-clang3.4
+#        * arm-linux-androideabi-clang3.5
+#        * mips64el-linux-android-4.9
+#        * mips64el-linux-android-clang3.4
+#        * mips64el-linux-android-clang3.5
 #        * mipsel-linux-android-4.6
-#        * mipsel-linux-android-clang3.1
-#        * x86-4.4.3
+#        * mipsel-linux-android-4.8
+#        * mipsel-linux-android-4.9
+#        * mipsel-linux-android-clang3.4
+#        * mipsel-linux-android-clang3.5
 #        * x86-4.6
-#        * x86-clang3.1
+#        * x86-4.8
+#        * x86-4.9
+#        * x86-clang3.4
+#        * x86-clang3.5
+#        * x86_64-4.9
+#        * x86_64-clang3.4
+#        * x86_64-clang3.5
 #
 #    ANDROID_FORCE_ARM_BUILD=OFF - set ON to generate 32-bit ARM instructions
 #      instead of Thumb. Is not available for "x86" (inapplicable) and
@@ -141,7 +133,7 @@
 #      libraries. Automatically turned for NDK r5x and r6x due to GLESv2
 #      problems.
 #
-#    LIBRARY_OUTPUT_PATH_ROOT=${CMAKE_BINARY_DIR} - where to output binary
+#    LIBRARY_OUTPUT_PATH_ROOT=${CMAKE_SOURCE_DIR} - where to output binary
 #      files. See additional details below.
 #
 #    ANDROID_SET_OBSOLETE_VARIABLES=ON - if set, then toolchain defines some
@@ -204,133 +196,26 @@
 #    ANDROID and BUILD_ANDROID will be set to true, you may test any of these
 #    variables to make necessary Android-specific configuration changes.
 #
-#    Also ARMEABI or ARMEABI_V7A or X86 or MIPS will be set true, mutually
-#    exclusive. NEON option will be set true if VFP is set to NEON.
+#    Also ARMEABI or ARMEABI_V7A or X86 or MIPS or ARM64_V8A or X86_64 or MIPS64
+#    will be set true, mutually exclusive. NEON option will be set true
+#    if VFP is set to NEON.
 #
 #    LIBRARY_OUTPUT_PATH_ROOT should be set in cache to determine where Android
 #    libraries will be installed.
-#    Default is ${CMAKE_BINARY_DIR}, and the android libs will always be
+#    Default is ${CMAKE_SOURCE_DIR}, and the android libs will always be
 #    under the ${LIBRARY_OUTPUT_PATH_ROOT}/libs/${ANDROID_NDK_ABI_NAME}
 #    (depending on the target ABI). This is convenient for Android packaging.
 #
-#  Change Log:
-#   - initial version December 2010
-#   - April 2011
-#     [+] added possibility to build with NDK (without standalone toolchain)
-#     [+] support cross-compilation on Windows (native, no cygwin support)
-#     [+] added compiler option to force "char" type to be signed
-#     [+] added toolchain option to compile to 32-bit ARM instructions
-#     [+] added toolchain option to disable SWIG search
-#     [+] added platform "armeabi-v7a with VFPV3"
-#     [~] ARM_TARGETS renamed to ARM_TARGET
-#     [+] EXECUTABLE_OUTPUT_PATH is set by toolchain (required on Windows)
-#     [~] Fixed bug with ANDROID_API_LEVEL variable
-#     [~] turn off SWIG search if it is not found first time
-#   - May 2011
-#     [~] ANDROID_LEVEL is renamed to ANDROID_API_LEVEL
-#     [+] ANDROID_API_LEVEL is detected by toolchain if not specified
-#     [~] added guard to prevent changing of output directories on the first
-#         cmake pass
-#     [~] toolchain exits with error if ARM_TARGET is not recognized
-#   - June 2011
-#     [~] default NDK path is updated for version r5c
-#     [+] variable CMAKE_SYSTEM_PROCESSOR is set based on ARM_TARGET
-#     [~] toolchain install directory is added to linker paths
-#     [-] removed SWIG-related stuff from toolchain
-#     [+] added macro find_host_package, find_host_program to search
-#         packages/programs on the host system
-#     [~] fixed path to STL library
-#   - July 2011
-#     [~] fixed options caching
-#     [~] search for all supported NDK versions
-#     [~] allowed spaces in NDK path
-#   - September 2011
-#     [~] updated for NDK r6b
-#   - November 2011
-#     [*] rewritten for NDK r7
-#     [+] x86 toolchain support (experimental)
-#     [+] added "armeabi-v6 with VFP" ABI for ARMv6 processors.
-#     [~] improved compiler and linker flags management
-#     [+] support different build flags for Release and Debug configurations
-#     [~] by default compiler flags the same as used by ndk-build (but only
-#         where reasonable)
-#     [~] ANDROID_NDK_TOOLCHAIN_ROOT is split to ANDROID_STANDALONE_TOOLCHAIN
-#         and ANDROID_TOOLCHAIN_ROOT
-#     [~] ARM_TARGET is renamed to ANDROID_ABI
-#     [~] ARMEABI_NDK_NAME is renamed to ANDROID_NDK_ABI_NAME
-#     [~] ANDROID_API_LEVEL is renamed to ANDROID_NATIVE_API_LEVEL
-#   - January 2012
-#     [+] added stlport_static support (experimental)
-#     [+] added special check for cygwin
-#     [+] filtered out hidden files (starting with .) while globbing inside NDK
-#     [+] automatically applied GLESv2 linkage fix for NDK revisions 5-6
-#     [+] added ANDROID_GET_ABI_RAWNAME to get NDK ABI names by CMake flags
-#   - February 2012
-#     [+] updated for NDK r7b
-#     [~] fixed cmake try_compile() command
-#     [~] Fix for missing install_name_tool on OS X
-#   - March 2012
-#     [~] fixed incorrect C compiler flags
-#     [~] fixed CMAKE_SYSTEM_PROCESSOR change on ANDROID_ABI change
-#     [+] improved toolchain loading speed
-#     [+] added assembler language support (.S)
-#     [+] allowed preset search paths and extra search suffixes
-#   - April 2012
-#     [+] updated for NDK r7c
-#     [~] fixed most of problems with compiler/linker flags and caching
-#     [+] added option ANDROID_FUNCTION_LEVEL_LINKING
-#   - May 2012
-#     [+] updated for NDK r8
-#     [+] added mips architecture support
-#   - August 2012
-#     [+] updated for NDK r8b
-#     [~] all intermediate files generated by toolchain are moved to CMakeFiles
-#     [~] libstdc++ and libsupc are removed from explicit link libraries
-#     [+] added CCache support (via NDK_CCACHE environment or cmake variable)
-#     [+] added gold linker support for NDK r8b
-#     [~] fixed mips linker flags for NDK r8b
-#   - September 2012
-#     [+] added NDK release name detection (see ANDROID_NDK_RELEASE)
-#     [+] added support for all C++ runtimes from NDK
-#         (system, gabi++, stlport, gnustl)
-#     [+] improved warnings on known issues of NDKs
-#     [~] use gold linker as default if available (NDK r8b)
-#     [~] globally turned off rpath
-#     [~] compiler options are aligned with NDK r8b
-#   - October 2012
-#     [~] fixed C++ linking: explicitly link with math library (OpenCV #2426)
-#   - November 2012
-#     [+] updated for NDK r8c
-#     [+] added support for clang compiler
-#   - December 2012
-#     [+] suppress warning about unused CMAKE_TOOLCHAIN_FILE variable
-#     [+] adjust API level to closest compatible as NDK does
-#     [~] fixed ccache full path search
-#     [+] updated for NDK r8d
-#     [~] compiler options are aligned with NDK r8d
-#   - March 2013
-#     [+] updated for NDK r8e (x86 version)
-#     [+] support x86_64 version of NDK
-#   - April 2013
-#     [+] support non-release NDK layouts (from Linaro git and Android git)
-#     [~] automatically detect if explicit link to crtbegin_*.o is needed
-#   - June 2013
-#     [~] fixed stl include path for standalone toolchain made by NDK >= r8c
-#   - July 2013
-#     [+] updated for NDK r9
-#   - November 2013
-#     [+] updated for NDK r9b
-#   - December 2013
-#     [+] updated for NDK r9c
-#   - January 2014
-#     [~] fix copying of shared STL
-#   - April 2014
-#     [+] updated for NDK r9d
 # ------------------------------------------------------------------------------
 
-cmake_minimum_required( VERSION 2.8.3 )
-if( ${CMAKE_VERSION} VERSION_GREATER 3.1 OR ${CMAKE_VERSION} VERSION_EQUAL 3.1 )
-  cmake_policy( SET CMP0054 NEW )
+# Modified by Lasse Oorni and Yao Wei Tjong for Urho3D
+
+cmake_minimum_required( VERSION 2.6.3 )
+
+# Urho3D: on Windows Cygwin-based NDK tools may fail in the linking phase with too long command line. Turn on response files to avoid this
+if( CMAKE_HOST_WIN32 )
+ set( CMAKE_C_USE_RESPONSE_FILE_FOR_OBJECTS 1 )
+ set( CMAKE_CXX_USE_RESPONSE_FILE_FOR_OBJECTS 1 )
 endif()
 
 if( DEFINED CMAKE_CROSSCOMPILING )
@@ -339,26 +224,31 @@ if( DEFINED CMAKE_CROSSCOMPILING )
 endif()
 
 if( CMAKE_TOOLCHAIN_FILE )
- # touch toolchain variable only to suppress "unused variable" warning
+ # touch toolchain variable to suppress "unused variable" warning
 endif()
 
+# inherit settings in recursive loads
 get_property( _CMAKE_IN_TRY_COMPILE GLOBAL PROPERTY IN_TRY_COMPILE )
 if( _CMAKE_IN_TRY_COMPILE )
- if( NOT ANDROID_TOOLCHAIN_CONFIG_FILE )
-  set( ANDROID_TOOLCHAIN_CONFIG_FILE "${CMAKE_BINARY_DIR}/../android.toolchain.config.cmake" )
- endif()
- include( "${ANDROID_TOOLCHAIN_CONFIG_FILE}" )
+ include( "${CMAKE_CURRENT_SOURCE_DIR}/../android.toolchain.config.cmake" OPTIONAL )
 endif()
 
 # this one is important
-set( CMAKE_SYSTEM_NAME Linux )
+if( CMAKE_VERSION VERSION_GREATER "3.0.99" )
+ set( CMAKE_SYSTEM_NAME Android )
+else()
+ set( CMAKE_SYSTEM_NAME Linux )
+endif()
+
 # this one not so much
 set( CMAKE_SYSTEM_VERSION 1 )
 
-# rpath makes low sense for Android
+# rpath makes low sence for Android
+set( CMAKE_SHARED_LIBRARY_RUNTIME_C_FLAG "" )
 set( CMAKE_SKIP_RPATH TRUE CACHE BOOL "If set, runtime paths are not added when using shared libraries." )
 
-set( ANDROID_SUPPORTED_NDK_VERSIONS ${ANDROID_EXTRA_NDK_VERSIONS} -r9d -r9c -r9b -r9 -r8e -r8d -r8c -r8b -r8 -r7c -r7b -r7 -r6b -r6 -r5c -r5b -r5 "" )
+# NDK search paths
+set( ANDROID_SUPPORTED_NDK_VERSIONS ${ANDROID_EXTRA_NDK_VERSIONS} -r13b -r10c -r10b -r10 -r9d -r9c -r9b -r9 -r8e -r8d -r8c -r8b -r8 -r7c -r7b -r7 -r6b -r6 -r5c -r5b -r5 "" )
 if(NOT DEFINED ANDROID_NDK_SEARCH_PATHS)
  if( CMAKE_HOST_WIN32 )
   file( TO_CMAKE_PATH "$ENV{PROGRAMFILES}" ANDROID_NDK_SEARCH_PATHS )
@@ -372,13 +262,22 @@ if(NOT DEFINED ANDROID_STANDALONE_TOOLCHAIN_SEARCH_PATH)
  set( ANDROID_STANDALONE_TOOLCHAIN_SEARCH_PATH /opt/android-toolchain )
 endif()
 
+# known ABIs
 set( ANDROID_SUPPORTED_ABIS_arm "armeabi-v7a;armeabi;armeabi-v7a with NEON;armeabi-v7a with VFPV3;armeabi-v6 with VFP" )
+set( ANDROID_SUPPORTED_ABIS_arm64 "arm64-v8a" )
 set( ANDROID_SUPPORTED_ABIS_x86 "x86" )
-set( ANDROID_SUPPORTED_ABIS_mipsel "mips" )
+set( ANDROID_SUPPORTED_ABIS_x86_64 "x86_64" )
+set( ANDROID_SUPPORTED_ABIS_mips "mips" )
+set( ANDROID_SUPPORTED_ABIS_mips64 "mips64" )
 
-set( ANDROID_DEFAULT_NDK_API_LEVEL 8 )
-set( ANDROID_DEFAULT_NDK_API_LEVEL_x86 9 )
-set( ANDROID_DEFAULT_NDK_API_LEVEL_mips 9 )
+# API level defaults
+# Urho3D: default to API 12
+set( ANDROID_DEFAULT_NDK_API_LEVEL 12 )
+set( ANDROID_DEFAULT_NDK_API_LEVEL_arm64 21 )
+set( ANDROID_DEFAULT_NDK_API_LEVEL_x86 12)
+set( ANDROID_DEFAULT_NDK_API_LEVEL_x86_64 21 )
+set( ANDROID_DEFAULT_NDK_API_LEVEL_mips 12 )
+set( ANDROID_DEFAULT_NDK_API_LEVEL_mips64 21 )
 
 
 macro( __LIST_FILTER listvar regex )
@@ -454,7 +353,7 @@ macro( __INIT_VARIABLE var_name )
 endmacro()
 
 macro( __DETECT_NATIVE_API_LEVEL _var _path )
- SET( __ndkApiLevelRegex "^[\t ]*#define[\t ]+__ANDROID_API__[\t ]+([0-9]+)[\t ]*$" )
+ SET( __ndkApiLevelRegex "^[\t ]*#define[\t ]+__ANDROID_API__[\t ]+([0-9]+)[\t ]*.*$" )
  FILE( STRINGS ${_path} __apiFileContent REGEX "${__ndkApiLevelRegex}" )
  if( NOT __apiFileContent )
   message( SEND_ERROR "Could not get Android native API level. Probably you have specified invalid level value, or your copy of NDK/toolchain is broken." )
@@ -562,33 +461,36 @@ endif( NOT ANDROID_NDK )
 
 # remember found paths
 if( ANDROID_NDK )
- get_filename_component( ANDROID_NDK "${ANDROID_NDK}" ABSOLUTE )
- set( ANDROID_NDK "${ANDROID_NDK}" CACHE INTERNAL "Path of the Android NDK" FORCE )
- set( BUILD_WITH_ANDROID_NDK True )
- if( EXISTS "${ANDROID_NDK}/RELEASE.TXT" )
-  file( STRINGS "${ANDROID_NDK}/RELEASE.TXT" ANDROID_NDK_RELEASE_FULL LIMIT_COUNT 1 REGEX r[0-9]+[a-z]? )
-  string( REGEX MATCH r[0-9]+[a-z]? ANDROID_NDK_RELEASE "${ANDROID_NDK_RELEASE_FULL}" )
- else()
-  set( ANDROID_NDK_RELEASE "r1x" )
-  set( ANDROID_NDK_RELEASE_FULL "unreleased" )
- endif()
+	get_filename_component( ANDROID_NDK "${ANDROID_NDK}" ABSOLUTE )
+	set( ANDROID_NDK "${ANDROID_NDK}" CACHE INTERNAL "Path of the Android NDK" FORCE )
+ 	set( BUILD_WITH_ANDROID_NDK True )
+ 	if( EXISTS "${ANDROID_NDK}/RELEASE.TXT" )
+  		file( STRINGS "${ANDROID_NDK}/RELEASE.TXT" ANDROID_NDK_RELEASE_FULL LIMIT_COUNT 1 REGEX "r[0-9]+[a-z]?" )
+  		string( REGEX MATCH "r([0-9]+)([a-z]?)" ANDROID_NDK_RELEASE "${ANDROID_NDK_RELEASE_FULL}" )
+ 	else()
+		set( ANDROID_NDK_RELEASE "r1x" )
+  		set( ANDROID_NDK_RELEASE_FULL "unreleased" )
+ 	endif()
+ 	string( REGEX REPLACE "r([0-9]+)([a-z]?)" "\\1*1000" ANDROID_NDK_RELEASE_NUM "${ANDROID_NDK_RELEASE}" )
+ 	string( FIND " abcdefghijklmnopqastuvwxyz" "${CMAKE_MATCH_2}" __ndkReleaseLetterNum )
+ 	math( EXPR ANDROID_NDK_RELEASE_NUM "${ANDROID_NDK_RELEASE_NUM}+${__ndkReleaseLetterNum}" )
 elseif( ANDROID_STANDALONE_TOOLCHAIN )
- get_filename_component( ANDROID_STANDALONE_TOOLCHAIN "${ANDROID_STANDALONE_TOOLCHAIN}" ABSOLUTE )
- # try to detect change
- if( CMAKE_AR )
-  string( LENGTH "${ANDROID_STANDALONE_TOOLCHAIN}" __length )
-  string( SUBSTRING "${CMAKE_AR}" 0 ${__length} __androidStandaloneToolchainPreviousPath )
-  if( NOT __androidStandaloneToolchainPreviousPath STREQUAL ANDROID_STANDALONE_TOOLCHAIN )
-   message( FATAL_ERROR "It is not possible to change path to the Android standalone toolchain on subsequent run." )
-  endif()
-  unset( __androidStandaloneToolchainPreviousPath )
-  unset( __length )
- endif()
- set( ANDROID_STANDALONE_TOOLCHAIN "${ANDROID_STANDALONE_TOOLCHAIN}" CACHE INTERNAL "Path of the Android standalone toolchain" FORCE )
- set( BUILD_WITH_STANDALONE_TOOLCHAIN True )
+	get_filename_component( ANDROID_STANDALONE_TOOLCHAIN "${ANDROID_STANDALONE_TOOLCHAIN}" ABSOLUTE )
+ 	# try to detect change
+ 	if( CMAKE_AR )
+  		string( LENGTH "${ANDROID_STANDALONE_TOOLCHAIN}" __length )
+  		string( SUBSTRING "${CMAKE_AR}" 0 ${__length} __androidStandaloneToolchainPreviousPath )
+  		if( NOT __androidStandaloneToolchainPreviousPath STREQUAL ANDROID_STANDALONE_TOOLCHAIN )
+   			message( FATAL_ERROR "It is not possible to change path to the Android standalone toolchain on subsequent run." )
+  		endif()
+  		unset( __androidStandaloneToolchainPreviousPath )
+  		unset( __length )
+ 	endif()
+ 	set( ANDROID_STANDALONE_TOOLCHAIN "${ANDROID_STANDALONE_TOOLCHAIN}" CACHE INTERNAL "Path of the Android standalone toolchain" FORCE )
+ 	set( BUILD_WITH_STANDALONE_TOOLCHAIN True )
 else()
- list(GET ANDROID_NDK_SEARCH_PATHS 0 ANDROID_NDK_SEARCH_PATH)
- message( FATAL_ERROR "Could not find neither Android NDK nor Android standalone toolchain.
+	list(GET ANDROID_NDK_SEARCH_PATHS 0 ANDROID_NDK_SEARCH_PATH)
+ 	message( FATAL_ERROR "Could not find neither Android NDK nor Android standalone toolchain.
     You should either set an environment variable:
       export ANDROID_NDK=~/my-android-ndk
     or
@@ -652,12 +554,18 @@ if( BUILD_WITH_STANDALONE_TOOLCHAIN )
  if( NOT __availableToolchainMachines )
   message( FATAL_ERROR "Could not determine machine name of your toolchain. Probably your Android standalone toolchain is broken." )
  endif()
- if( __availableToolchainMachines MATCHES i686 )
+ if( __availableToolchainMachines MATCHES x86_64 )
+  set( __availableToolchainArchs "x86_64" )
+ elseif( __availableToolchainMachines MATCHES i686 )
   set( __availableToolchainArchs "x86" )
+ elseif( __availableToolchainMachines MATCHES aarch64 )
+  set( __availableToolchainArchs "arm64" )
  elseif( __availableToolchainMachines MATCHES arm )
   set( __availableToolchainArchs "arm" )
+ elseif( __availableToolchainMachines MATCHES mips64el )
+  set( __availableToolchainArchs "mips64" )
  elseif( __availableToolchainMachines MATCHES mipsel )
-  set( __availableToolchainArchs "mipsel" )
+  set( __availableToolchainArchs "mips" )
  endif()
  execute_process( COMMAND "${ANDROID_STANDALONE_TOOLCHAIN}/bin/${__availableToolchainMachines}-gcc${TOOL_OS_SUFFIX}" -dumpversion
                   OUTPUT_VARIABLE __availableToolchainCompilerVersions OUTPUT_STRIP_TRAILING_WHITESPACE )
@@ -673,27 +581,43 @@ endif()
 macro( __GLOB_NDK_TOOLCHAINS __availableToolchainsVar __availableToolchainsLst __toolchain_subpath )
  foreach( __toolchain ${${__availableToolchainsLst}} )
   if( "${__toolchain}" MATCHES "-clang3[.][0-9]$" AND NOT EXISTS "${ANDROID_NDK_TOOLCHAINS_PATH}/${__toolchain}${__toolchain_subpath}" )
-   string( REGEX REPLACE "-clang3[.][0-9]$" "-4.6" __gcc_toolchain "${__toolchain}" )
+   SET( __toolchainVersionRegex "^TOOLCHAIN_VERSION[\t ]+:=[\t ]+(.*)$" )
+   FILE( STRINGS "${ANDROID_NDK_TOOLCHAINS_PATH}/${__toolchain}/setup.mk" __toolchainVersionStr REGEX "${__toolchainVersionRegex}" )
+   if( __toolchainVersionStr )
+    string( REGEX REPLACE "${__toolchainVersionRegex}" "\\1" __toolchainVersionStr "${__toolchainVersionStr}" )
+    string( REGEX REPLACE "-clang3[.][0-9]$" "-${__toolchainVersionStr}" __gcc_toolchain "${__toolchain}" )
+   else()
+    string( REGEX REPLACE "-clang3[.][0-9]$" "-4.6" __gcc_toolchain "${__toolchain}" )
+   endif()
+   unset( __toolchainVersionStr )
+   unset( __toolchainVersionRegex )
   else()
    set( __gcc_toolchain "${__toolchain}" )
   endif()
   __DETECT_TOOLCHAIN_MACHINE_NAME( __machine "${ANDROID_NDK_TOOLCHAINS_PATH}/${__gcc_toolchain}${__toolchain_subpath}" )
   if( __machine )
    string( REGEX MATCH "[0-9]+[.][0-9]+([.][0-9x]+)?$" __version "${__gcc_toolchain}" )
-   if( __machine MATCHES i686 )
+   if( __machine MATCHES x86_64 )
+    set( __arch "x86_64" )
+   elseif( __machine MATCHES i686 )
     set( __arch "x86" )
+   elseif( __machine MATCHES aarch64 )
+    set( __arch "arm64" )
    elseif( __machine MATCHES arm )
     set( __arch "arm" )
+   elseif( __machine MATCHES mips64el )
+    set( __arch "mips64" )
    elseif( __machine MATCHES mipsel )
-    set( __arch "mipsel" )
+    set( __arch "mips" )
    else()
-    unset( __arch )
+    set( __arch "" )
    endif()
-   if( __arch )
-     list( APPEND __availableToolchainMachines "${__machine}" )
-     list( APPEND __availableToolchainArchs "${__arch}" )
-     list( APPEND __availableToolchainCompilerVersions "${__version}" )
-     list( APPEND ${__availableToolchainsVar} "${__toolchain}" )
+   #message("machine: !${__machine}!\narch: !${__arch}!\nversion: !${__version}!\ntoolchain: !${__toolchain}!\n")
+   if (__arch)
+    list( APPEND __availableToolchainMachines "${__machine}" )
+    list( APPEND __availableToolchainArchs "${__arch}" )
+    list( APPEND __availableToolchainCompilerVersions "${__version}" )
+    list( APPEND ${__availableToolchainsVar} "${__toolchain}" )
    endif()
   endif()
   unset( __gcc_toolchain )
@@ -770,28 +694,45 @@ if( ANDROID_ABI STREQUAL "x86" )
  set( X86 true )
  set( ANDROID_NDK_ABI_NAME "x86" )
  set( ANDROID_ARCH_NAME "x86" )
- set( ANDROID_ARCH_FULLNAME "x86" )
  set( ANDROID_LLVM_TRIPLE "i686-none-linux-android" )
  set( CMAKE_SYSTEM_PROCESSOR "i686" )
+elseif( ANDROID_ABI STREQUAL "x86_64" )
+ set( X86 true )
+ set( X86_64 true )
+ set( ANDROID_NDK_ABI_NAME "x86_64" )
+ set( ANDROID_ARCH_NAME "x86_64" )
+ set( CMAKE_SYSTEM_PROCESSOR "x86_64" )
+ set( ANDROID_LLVM_TRIPLE "x86_64-none-linux-android" )
+elseif( ANDROID_ABI STREQUAL "mips64" )
+ set( MIPS64 true )
+ set( ANDROID_NDK_ABI_NAME "mips64" )
+ set( ANDROID_ARCH_NAME "mips64" )
+ set( ANDROID_LLVM_TRIPLE "mips64el-none-linux-android" )
+ set( CMAKE_SYSTEM_PROCESSOR "mips64" )
 elseif( ANDROID_ABI STREQUAL "mips" )
  set( MIPS true )
  set( ANDROID_NDK_ABI_NAME "mips" )
  set( ANDROID_ARCH_NAME "mips" )
- set( ANDROID_ARCH_FULLNAME "mipsel" )
  set( ANDROID_LLVM_TRIPLE "mipsel-none-linux-android" )
  set( CMAKE_SYSTEM_PROCESSOR "mips" )
+elseif( ANDROID_ABI STREQUAL "arm64-v8a" )
+ set( ARM64_V8A true )
+ set( ANDROID_NDK_ABI_NAME "arm64-v8a" )
+ set( ANDROID_ARCH_NAME "arm64" )
+ set( ANDROID_LLVM_TRIPLE "aarch64-none-linux-android" )
+ set( CMAKE_SYSTEM_PROCESSOR "aarch64" )
+ set( VFPV3 true )
+ set( NEON true )
 elseif( ANDROID_ABI STREQUAL "armeabi" )
  set( ARMEABI true )
  set( ANDROID_NDK_ABI_NAME "armeabi" )
  set( ANDROID_ARCH_NAME "arm" )
- set( ANDROID_ARCH_FULLNAME "arm" )
  set( ANDROID_LLVM_TRIPLE "armv5te-none-linux-androideabi" )
  set( CMAKE_SYSTEM_PROCESSOR "armv5te" )
 elseif( ANDROID_ABI STREQUAL "armeabi-v6 with VFP" )
  set( ARMEABI_V6 true )
  set( ANDROID_NDK_ABI_NAME "armeabi" )
  set( ANDROID_ARCH_NAME "arm" )
- set( ANDROID_ARCH_FULLNAME "arm" )
  set( ANDROID_LLVM_TRIPLE "armv5te-none-linux-androideabi" )
  set( CMAKE_SYSTEM_PROCESSOR "armv6" )
  # need always fallback to older platform
@@ -800,14 +741,12 @@ elseif( ANDROID_ABI STREQUAL "armeabi-v7a")
  set( ARMEABI_V7A true )
  set( ANDROID_NDK_ABI_NAME "armeabi-v7a" )
  set( ANDROID_ARCH_NAME "arm" )
- set( ANDROID_ARCH_FULLNAME "arm" )
  set( ANDROID_LLVM_TRIPLE "armv7-none-linux-androideabi" )
  set( CMAKE_SYSTEM_PROCESSOR "armv7-a" )
 elseif( ANDROID_ABI STREQUAL "armeabi-v7a with VFPV3" )
  set( ARMEABI_V7A true )
  set( ANDROID_NDK_ABI_NAME "armeabi-v7a" )
  set( ANDROID_ARCH_NAME "arm" )
- set( ANDROID_ARCH_FULLNAME "arm" )
  set( ANDROID_LLVM_TRIPLE "armv7-none-linux-androideabi" )
  set( CMAKE_SYSTEM_PROCESSOR "armv7-a" )
  set( VFPV3 true )
@@ -815,7 +754,6 @@ elseif( ANDROID_ABI STREQUAL "armeabi-v7a with NEON" )
  set( ARMEABI_V7A true )
  set( ANDROID_NDK_ABI_NAME "armeabi-v7a" )
  set( ANDROID_ARCH_NAME "arm" )
- set( ANDROID_ARCH_FULLNAME "arm" )
  set( ANDROID_LLVM_TRIPLE "armv7-none-linux-androideabi" )
  set( CMAKE_SYSTEM_PROCESSOR "armv7-a" )
  set( VFPV3 true )
@@ -849,7 +787,7 @@ if( ANDROID_TOOLCHAIN_NAME )
 To configure the toolchain set CMake variable ANDROID_TOOLCHAIN_NAME to one of the following values:\n${toolchains_list}\n" )
  endif()
  list( GET __availableToolchainArchs ${__toolchainIdx} __toolchainArch )
- if( NOT __toolchainArch STREQUAL ANDROID_ARCH_FULLNAME )
+ if( NOT __toolchainArch STREQUAL ANDROID_ARCH_NAME )
   message( SEND_ERROR "Selected toolchain \"${ANDROID_TOOLCHAIN_NAME}\" is not able to compile binaries for the \"${ANDROID_ARCH_NAME}\" platform." )
  endif()
 else()
@@ -860,7 +798,7 @@ else()
  math( EXPR __availableToolchainsCount "${__availableToolchainsCount}-1" )
  foreach( __idx RANGE ${__availableToolchainsCount} )
   list( GET __availableToolchainArchs ${__idx} __toolchainArch )
-  if( __toolchainArch STREQUAL ANDROID_ARCH_FULLNAME )
+  if( __toolchainArch STREQUAL ANDROID_ARCH_NAME )
    list( GET __availableToolchainCompilerVersions ${__idx} __toolchainVersion )
    string( REPLACE "x" "99" __toolchainVersion "${__toolchainVersion}")
    if( __toolchainVersion VERSION_GREATER __toolchainMaxVersion )
@@ -889,15 +827,16 @@ unset( __availableToolchainCompilerVersions )
 
 # choose native API level
 __INIT_VARIABLE( ANDROID_NATIVE_API_LEVEL ENV_ANDROID_NATIVE_API_LEVEL ANDROID_API_LEVEL ENV_ANDROID_API_LEVEL ANDROID_STANDALONE_TOOLCHAIN_API_LEVEL ANDROID_DEFAULT_NDK_API_LEVEL_${ANDROID_ARCH_NAME} ANDROID_DEFAULT_NDK_API_LEVEL )
-string( REGEX MATCH "[0-9]+" ANDROID_NATIVE_API_LEVEL "${ANDROID_NATIVE_API_LEVEL}" )
+string( REPLACE "android-" "" ANDROID_NATIVE_API_LEVEL "${ANDROID_NATIVE_API_LEVEL}" )
+string( STRIP "${ANDROID_NATIVE_API_LEVEL}" ANDROID_NATIVE_API_LEVEL )
 # adjust API level
 set( __real_api_level ${ANDROID_DEFAULT_NDK_API_LEVEL_${ANDROID_ARCH_NAME}} )
 foreach( __level ${ANDROID_SUPPORTED_NATIVE_API_LEVELS} )
- if( NOT __level GREATER ANDROID_NATIVE_API_LEVEL AND NOT __level LESS __real_api_level )
+ if( (__level LESS ANDROID_NATIVE_API_LEVEL OR __level STREQUAL ANDROID_NATIVE_API_LEVEL) AND NOT __level LESS __real_api_level )
   set( __real_api_level ${__level} )
  endif()
 endforeach()
-if( __real_api_level AND NOT ANDROID_NATIVE_API_LEVEL EQUAL __real_api_level )
+if( __real_api_level AND NOT ANDROID_NATIVE_API_LEVEL STREQUAL __real_api_level )
  message( STATUS "Adjusting Android API level 'android-${ANDROID_NATIVE_API_LEVEL}' to 'android-${__real_api_level}'")
  set( ANDROID_NATIVE_API_LEVEL ${__real_api_level} )
 endif()
@@ -909,7 +848,7 @@ if( __levelIdx EQUAL -1 )
 else()
  if( BUILD_WITH_ANDROID_NDK )
   __DETECT_NATIVE_API_LEVEL( __realApiLevel "${ANDROID_NDK}/platforms/android-${ANDROID_NATIVE_API_LEVEL}/arch-${ANDROID_ARCH_NAME}/usr/include/android/api-level.h" )
-  if( NOT __realApiLevel EQUAL ANDROID_NATIVE_API_LEVEL )
+  if( NOT __realApiLevel EQUAL ANDROID_NATIVE_API_LEVEL AND NOT __realApiLevel GREATER 9000 )
    message( SEND_ERROR "Specified Android API level (${ANDROID_NATIVE_API_LEVEL}) does not match to the level found (${__realApiLevel}). Probably your copy of NDK is broken." )
   endif()
   unset( __realApiLevel )
@@ -926,8 +865,8 @@ unset( __levelIdx )
 # remember target ABI
 set( ANDROID_ABI "${ANDROID_ABI}" CACHE STRING "The target ABI for Android. If arm, then armeabi-v7a is recommended for hardware floating point." FORCE )
 if( CMAKE_VERSION VERSION_GREATER "2.8" )
- list( SORT ANDROID_SUPPORTED_ABIS_${ANDROID_ARCH_FULLNAME} )
- set_property( CACHE ANDROID_ABI PROPERTY STRINGS ${ANDROID_SUPPORTED_ABIS_${ANDROID_ARCH_FULLNAME}} )
+ list( SORT ANDROID_SUPPORTED_ABIS_${ANDROID_ARCH_NAME} )
+ set_property( CACHE ANDROID_ABI PROPERTY STRINGS ${ANDROID_SUPPORTED_ABIS_${ANDROID_ARCH_NAME}} )
 endif()
 
 
@@ -949,7 +888,7 @@ set( ANDROID_STL_FORCE_FEATURES ON CACHE BOOL "automatically configure rtti and
 mark_as_advanced( ANDROID_STL ANDROID_STL_FORCE_FEATURES )
 
 if( BUILD_WITH_ANDROID_NDK )
- if( NOT "${ANDROID_STL}" MATCHES "^(none|system|system_re|gabi\\+\\+_static|gabi\\+\\+_shared|stlport_static|stlport_shared|gnustl_static|gnustl_shared)$")
+ if( NOT "${ANDROID_STL}" MATCHES "^(none|system|system_re|gabi\\+\\+_static|gabi\\+\\+_shared|stlport_static|stlport_shared|gnustl_static|gnustl_shared|c\\+\\+_static|c\\+\\+_shared)$")
   message( FATAL_ERROR "ANDROID_STL is set to invalid value \"${ANDROID_STL}\".
 The possible values are:
   none           -> Do not configure the runtime.
@@ -961,6 +900,8 @@ The possible values are:
   stlport_shared -> Use the STLport runtime as a shared library.
   gnustl_static  -> (default) Use the GNU STL as a static library.
   gnustl_shared  -> Use the GNU STL as a shared library.
+  c++_static  -> The LLVM libc++ runtime (static library).
+  c++_shared  -> The LLVM libc++ runtime (shared library).
 " )
  endif()
 elseif( BUILD_WITH_STANDALONE_TOOLCHAIN )
@@ -1050,131 +991,145 @@ if( BUILD_WITH_STANDALONE_TOOLCHAIN )
      ${__libsupcxx}
    " )
   endif()
-  if( ANDROID_STL STREQUAL "gnustl_shared" )
-   if( ARMEABI_V7A AND EXISTS "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/${CMAKE_SYSTEM_PROCESSOR}/libgnustl_shared.so" )
-    set( __libstl "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/${CMAKE_SYSTEM_PROCESSOR}/libgnustl_shared.so" )
-   elseif( ARMEABI AND NOT ANDROID_FORCE_ARM_BUILD AND EXISTS "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/thumb/libgnustl_shared.so" )
-    set( __libstl "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/thumb/libgnustl_shared.so" )
-   elseif( EXISTS "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/libgnustl_shared.so" )
-    set( __libstl "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/libgnustl_shared.so" )
-   endif()
-  endif()
+	if( ANDROID_STL STREQUAL "gnustl_shared" )
+		if( ARMEABI_V7A AND EXISTS "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/${CMAKE_SYSTEM_PROCESSOR}/libgnustl_shared.so" )
+    		set( __libstl "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/${CMAKE_SYSTEM_PROCESSOR}/libgnustl_shared.so" )
+   		elseif( ARMEABI AND NOT ANDROID_FORCE_ARM_BUILD AND EXISTS "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/thumb/libgnustl_shared.so" )
+    		set( __libstl "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/thumb/libgnustl_shared.so" )
+   		elseif( EXISTS "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/libgnustl_shared.so" )
+    		set( __libstl "${ANDROID_STANDALONE_TOOLCHAIN}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/libgnustl_shared.so" )
+   		endif()
+  	endif()
  endif()
 endif()
 
 # clang
 if( "${ANDROID_TOOLCHAIN_NAME}" STREQUAL "standalone-clang" )
- set( ANDROID_COMPILER_IS_CLANG 1 )
- execute_process( COMMAND "${ANDROID_CLANG_TOOLCHAIN_ROOT}/bin/clang${TOOL_OS_SUFFIX}" --version OUTPUT_VARIABLE ANDROID_CLANG_VERSION OUTPUT_STRIP_TRAILING_WHITESPACE )
- string( REGEX MATCH "[0-9]+[.][0-9]+" ANDROID_CLANG_VERSION "${ANDROID_CLANG_VERSION}")
+	set( ANDROID_COMPILER_IS_CLANG 1 )
+	execute_process( COMMAND "${ANDROID_CLANG_TOOLCHAIN_ROOT}/bin/clang${TOOL_OS_SUFFIX}" --version OUTPUT_VARIABLE ANDROID_CLANG_VERSION OUTPUT_STRIP_TRAILING_WHITESPACE )
+ 	string( REGEX MATCH "[0-9]+[.][0-9]+" ANDROID_CLANG_VERSION "${ANDROID_CLANG_VERSION}")
 elseif( "${ANDROID_TOOLCHAIN_NAME}" MATCHES "-clang3[.][0-9]?$" )
- string( REGEX MATCH "3[.][0-9]$" ANDROID_CLANG_VERSION "${ANDROID_TOOLCHAIN_NAME}")
- string( REGEX REPLACE "-clang${ANDROID_CLANG_VERSION}$" "-4.6" ANDROID_GCC_TOOLCHAIN_NAME "${ANDROID_TOOLCHAIN_NAME}" )
- if( NOT EXISTS "${ANDROID_NDK_TOOLCHAINS_PATH}/llvm-${ANDROID_CLANG_VERSION}${ANDROID_NDK_TOOLCHAINS_SUBPATH}/bin/clang${TOOL_OS_SUFFIX}" )
-  message( FATAL_ERROR "Could not find the Clang compiler driver" )
- endif()
- set( ANDROID_COMPILER_IS_CLANG 1 )
- set( ANDROID_CLANG_TOOLCHAIN_ROOT "${ANDROID_NDK_TOOLCHAINS_PATH}/llvm-${ANDROID_CLANG_VERSION}${ANDROID_NDK_TOOLCHAINS_SUBPATH}" )
+ 	string( REGEX MATCH "3[.][0-9]$" ANDROID_CLANG_VERSION "${ANDROID_TOOLCHAIN_NAME}")
+ 	string( REGEX REPLACE "-clang${ANDROID_CLANG_VERSION}$" "-${ANDROID_COMPILER_VERSION}" ANDROID_GCC_TOOLCHAIN_NAME "${ANDROID_TOOLCHAIN_NAME}" )
+ 	if( NOT EXISTS "${ANDROID_NDK_TOOLCHAINS_PATH}/llvm-${ANDROID_CLANG_VERSION}${ANDROID_NDK_TOOLCHAINS_SUBPATH}/bin/clang${TOOL_OS_SUFFIX}" )
+  		message( FATAL_ERROR "Could not find the Clang compiler driver" )
+	endif()
+	set( ANDROID_COMPILER_IS_CLANG 1 )
+	set( ANDROID_CLANG_TOOLCHAIN_ROOT "${ANDROID_NDK_TOOLCHAINS_PATH}/llvm-${ANDROID_CLANG_VERSION}${ANDROID_NDK_TOOLCHAINS_SUBPATH}" )
 else()
- set( ANDROID_GCC_TOOLCHAIN_NAME "${ANDROID_TOOLCHAIN_NAME}" )
- unset( ANDROID_COMPILER_IS_CLANG CACHE )
+	set( ANDROID_GCC_TOOLCHAIN_NAME "${ANDROID_TOOLCHAIN_NAME}" )
+	unset( ANDROID_COMPILER_IS_CLANG CACHE )
 endif()
 
 string( REPLACE "." "" _clang_name "clang${ANDROID_CLANG_VERSION}" )
 if( NOT EXISTS "${ANDROID_CLANG_TOOLCHAIN_ROOT}/bin/${_clang_name}${TOOL_OS_SUFFIX}" )
- set( _clang_name "clang" )
+	set( _clang_name "clang" )
 endif()
 
 
 # setup paths and STL for NDK
 if( BUILD_WITH_ANDROID_NDK )
- set( ANDROID_TOOLCHAIN_ROOT "${ANDROID_NDK_TOOLCHAINS_PATH}/${ANDROID_GCC_TOOLCHAIN_NAME}${ANDROID_NDK_TOOLCHAINS_SUBPATH}" )
- set( ANDROID_SYSROOT "${ANDROID_NDK}/platforms/android-${ANDROID_NATIVE_API_LEVEL}/arch-${ANDROID_ARCH_NAME}" )
-
- if( ANDROID_STL STREQUAL "none" )
-  # do nothing
- elseif( ANDROID_STL STREQUAL "system" )
-  set( ANDROID_RTTI             OFF )
-  set( ANDROID_EXCEPTIONS       OFF )
-  set( ANDROID_STL_INCLUDE_DIRS "${ANDROID_NDK}/sources/cxx-stl/system/include" )
- elseif( ANDROID_STL STREQUAL "system_re" )
-  set( ANDROID_RTTI             ON )
-  set( ANDROID_EXCEPTIONS       ON )
-  set( ANDROID_STL_INCLUDE_DIRS "${ANDROID_NDK}/sources/cxx-stl/system/include" )
- elseif( ANDROID_STL MATCHES "gabi" )
-  if( ANDROID_NDK_RELEASE STRLESS "r7" )
-   message( FATAL_ERROR "gabi++ is not awailable in your NDK. You have to upgrade to NDK r7 or newer to use gabi++.")
-  endif()
-  set( ANDROID_RTTI             ON )
-  set( ANDROID_EXCEPTIONS       OFF )
-  set( ANDROID_STL_INCLUDE_DIRS "${ANDROID_NDK}/sources/cxx-stl/gabi++/include" )
-  set( __libstl                 "${ANDROID_NDK}/sources/cxx-stl/gabi++/libs/${ANDROID_NDK_ABI_NAME}/libgabi++_static.a" )
- elseif( ANDROID_STL MATCHES "stlport" )
-  if( NOT ANDROID_NDK_RELEASE STRLESS "r8d" )
-   set( ANDROID_EXCEPTIONS       ON )
-  else()
-   set( ANDROID_EXCEPTIONS       OFF )
-  endif()
-  if( ANDROID_NDK_RELEASE STRLESS "r7" )
-   set( ANDROID_RTTI            OFF )
-  else()
-   set( ANDROID_RTTI            ON )
-  endif()
-  set( ANDROID_STL_INCLUDE_DIRS "${ANDROID_NDK}/sources/cxx-stl/stlport/stlport" )
-  set( __libstl                 "${ANDROID_NDK}/sources/cxx-stl/stlport/libs/${ANDROID_NDK_ABI_NAME}/libstlport_static.a" )
- elseif( ANDROID_STL MATCHES "gnustl" )
-  set( ANDROID_EXCEPTIONS       ON )
-  set( ANDROID_RTTI             ON )
-  if( EXISTS "${ANDROID_NDK}/sources/cxx-stl/gnu-libstdc++/${ANDROID_COMPILER_VERSION}" )
-   if( ARMEABI_V7A AND ANDROID_COMPILER_VERSION VERSION_EQUAL "4.7" AND ANDROID_NDK_RELEASE STREQUAL "r8d" )
-    # gnustl binary for 4.7 compiler is buggy :(
-    # TODO: look for right fix
-    set( __libstl                "${ANDROID_NDK}/sources/cxx-stl/gnu-libstdc++/4.6" )
-   else()
-    set( __libstl                "${ANDROID_NDK}/sources/cxx-stl/gnu-libstdc++/${ANDROID_COMPILER_VERSION}" )
-   endif()
-  else()
-   set( __libstl                "${ANDROID_NDK}/sources/cxx-stl/gnu-libstdc++" )
-  endif()
-  set( ANDROID_STL_INCLUDE_DIRS "${__libstl}/include" "${__libstl}/libs/${ANDROID_NDK_ABI_NAME}/include" )
-  if( EXISTS "${__libstl}/libs/${ANDROID_NDK_ABI_NAME}/libgnustl_static.a" )
-   set( __libstl                "${__libstl}/libs/${ANDROID_NDK_ABI_NAME}/libgnustl_static.a" )
-  else()
-   set( __libstl                "${__libstl}/libs/${ANDROID_NDK_ABI_NAME}/libstdc++.a" )
-  endif()
- else()
-  message( FATAL_ERROR "Unknown runtime: ${ANDROID_STL}" )
- endif()
- # find libsupc++.a - rtti & exceptions
- if( ANDROID_STL STREQUAL "system_re" OR ANDROID_STL MATCHES "gnustl" )
-  set( __libsupcxx "${ANDROID_NDK}/sources/cxx-stl/gnu-libstdc++/${ANDROID_COMPILER_VERSION}/libs/${ANDROID_NDK_ABI_NAME}/libsupc++.a" ) # r8b or newer
-  if( NOT EXISTS "${__libsupcxx}" )
-   set( __libsupcxx "${ANDROID_NDK}/sources/cxx-stl/gnu-libstdc++/libs/${ANDROID_NDK_ABI_NAME}/libsupc++.a" ) # r7-r8
-  endif()
-  if( NOT EXISTS "${__libsupcxx}" ) # before r7
-   if( ARMEABI_V7A )
-    if( ANDROID_FORCE_ARM_BUILD )
-     set( __libsupcxx "${ANDROID_TOOLCHAIN_ROOT}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/${CMAKE_SYSTEM_PROCESSOR}/libsupc++.a" )
-    else()
-     set( __libsupcxx "${ANDROID_TOOLCHAIN_ROOT}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/${CMAKE_SYSTEM_PROCESSOR}/thumb/libsupc++.a" )
-    endif()
-   elseif( ARMEABI AND NOT ANDROID_FORCE_ARM_BUILD )
-    set( __libsupcxx "${ANDROID_TOOLCHAIN_ROOT}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/thumb/libsupc++.a" )
-   else()
-    set( __libsupcxx "${ANDROID_TOOLCHAIN_ROOT}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/libsupc++.a" )
-   endif()
-  endif()
-  if( NOT EXISTS "${__libsupcxx}")
-   message( ERROR "Could not find libsupc++.a for a chosen platform. Either your NDK is not supported or is broken.")
-  endif()
- endif()
+    set( ANDROID_TOOLCHAIN_ROOT "${ANDROID_NDK_TOOLCHAINS_PATH}/${ANDROID_GCC_TOOLCHAIN_NAME}${ANDROID_NDK_TOOLCHAINS_SUBPATH}" )
+    set( ANDROID_SYSROOT "${ANDROID_NDK}/platforms/android-${ANDROID_NATIVE_API_LEVEL}/arch-${ANDROID_ARCH_NAME}" )
+    if( ANDROID_STL STREQUAL "none" )
+        # do nothing
+    elseif( ANDROID_STL STREQUAL "system" )
+        set( ANDROID_RTTI             OFF )
+        set( ANDROID_EXCEPTIONS       OFF )
+        set( ANDROID_STL_INCLUDE_DIRS "${ANDROID_NDK}/sources/cxx-stl/system/include" )
+    elseif( ANDROID_STL STREQUAL "system_re" )
+        set( ANDROID_RTTI             ON )
+        set( ANDROID_EXCEPTIONS       ON )
+        set( ANDROID_STL_INCLUDE_DIRS "${ANDROID_NDK}/sources/cxx-stl/system/include" )
+    elseif( ANDROID_STL MATCHES "gabi" )
+        if( ANDROID_NDK_RELEASE_NUM LESS 7000 ) # before r7
+            message( FATAL_ERROR "gabi++ is not awailable in your NDK. You have to upgrade to NDK r7 or newer to use gabi++.")
+        endif()
+        set( ANDROID_RTTI             ON )
+        set( ANDROID_EXCEPTIONS       OFF )
+        set( ANDROID_STL_INCLUDE_DIRS "${ANDROID_NDK}/sources/cxx-stl/gabi++/include" )
+        set( __libstl                 "${ANDROID_NDK}/sources/cxx-stl/gabi++/libs/${ANDROID_NDK_ABI_NAME}/libgabi++_static.a" )
+    elseif( ANDROID_STL MATCHES "stlport" )
+        if( NOT ANDROID_NDK_RELEASE_NUM LESS 8004 ) # before r8d
+            set( ANDROID_EXCEPTIONS       ON )
+        else()
+            set( ANDROID_EXCEPTIONS       OFF )
+        endif()
+        
+        if( ANDROID_NDK_RELEASE_NUM LESS 7000 ) # before r7
+            set( ANDROID_RTTI            OFF )
+        else()
+            set( ANDROID_RTTI            ON )
+        endif()
+        
+        set( ANDROID_STL_INCLUDE_DIRS "${ANDROID_NDK}/sources/cxx-stl/stlport/stlport" )
+        set( __libstl                 "${ANDROID_NDK}/sources/cxx-stl/stlport/libs/${ANDROID_NDK_ABI_NAME}/libstlport_static.a" )
+    elseif( ANDROID_STL MATCHES "gnustl" )
+        set( ANDROID_EXCEPTIONS       ON )
+        set( ANDROID_RTTI             ON )
+        if( EXISTS "${ANDROID_NDK}/sources/cxx-stl/gnu-libstdc++/${ANDROID_COMPILER_VERSION}" )
+            if( ARMEABI_V7A AND ANDROID_COMPILER_VERSION VERSION_EQUAL "4.7" AND ANDROID_NDK_RELEASE STREQUAL "r8d" )
+            	# gnustl binary for 4.7 compiler is buggy :(
+    			# TODO: look for right fix
+    			set( __libstl                "${ANDROID_NDK}/sources/cxx-stl/gnu-libstdc++/4.6" )
+   			else()
+    			set( __libstl                "${ANDROID_NDK}/sources/cxx-stl/gnu-libstdc++/${ANDROID_COMPILER_VERSION}" )
+   			endif()
+  		else()
+   			set( __libstl                "${ANDROID_NDK}/sources/cxx-stl/gnu-libstdc++" )
+  		endif()
+
+  		set( ANDROID_STL_INCLUDE_DIRS "${__libstl}/include" "${__libstl}/libs/${ANDROID_NDK_ABI_NAME}/include" )
+  		if( EXISTS "${__libstl}/libs/${ANDROID_NDK_ABI_NAME}/libgnustl_static.a" )
+   			set( __libstl                "${__libstl}/libs/${ANDROID_NDK_ABI_NAME}/libgnustl_static.a" )
+  		else()
+   			set( __libstl                "${__libstl}/libs/${ANDROID_NDK_ABI_NAME}/libstdc++.a" )
+  		endif()
+  	elseif( ANDROID_STL MATCHES "c\\+\\+" )
+		set( ANDROID_EXCEPTIONS       ON )
+        set( ANDROID_RTTI             ON )
+   		set( __libstl                "${ANDROID_NDK}/sources/cxx-stl/llvm-libc++" )
+  		set( ANDROID_STL_INCLUDE_DIRS "${__libstl}/include" )
+   		set( __libstl                "${__libstl}/libs/${ANDROID_NDK_ABI_NAME}/libc++_static.a" )
+	else()
+		message( FATAL_ERROR "Unknown runtime: ${ANDROID_STL}" )
+	endif()
+
+	# find libsupc++.a - rtti & exceptions
+	if( ANDROID_STL STREQUAL "c++" )
+		# Do nothing
+	elseif( ANDROID_STL STREQUAL "system_re" OR ANDROID_STL MATCHES "gnustl" )
+		set( __libsupcxx "${ANDROID_NDK}/sources/cxx-stl/gnu-libstdc++/${ANDROID_COMPILER_VERSION}/libs/${ANDROID_NDK_ABI_NAME}/libsupc++.a" ) # r8b or newer
+  		if( NOT EXISTS "${__libsupcxx}" )
+   			set( __libsupcxx "${ANDROID_NDK}/sources/cxx-stl/gnu-libstdc++/libs/${ANDROID_NDK_ABI_NAME}/libsupc++.a" ) # r7-r8
+  		endif()
+  	
+		if( NOT EXISTS "${__libsupcxx}" ) # before r7
+  	 		if( ARMEABI_V7A )
+    			if( ANDROID_FORCE_ARM_BUILD )
+     				set( __libsupcxx "${ANDROID_TOOLCHAIN_ROOT}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/${CMAKE_SYSTEM_PROCESSOR}/libsupc++.a" )
+    			else()
+     				set( __libsupcxx "${ANDROID_TOOLCHAIN_ROOT}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/${CMAKE_SYSTEM_PROCESSOR}/thumb/libsupc++.a" )
+    			endif()
+			elseif( ARMEABI AND NOT ANDROID_FORCE_ARM_BUILD )
+    			set( __libsupcxx "${ANDROID_TOOLCHAIN_ROOT}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/thumb/libsupc++.a" )
+   			else()
+    			set( __libsupcxx "${ANDROID_TOOLCHAIN_ROOT}/${ANDROID_TOOLCHAIN_MACHINE_NAME}/lib/libsupc++.a" )
+   			endif()
+		endif()
+		
+		if( NOT EXISTS "${__libsupcxx}")
+			message( ERROR "Could not find libsupc++.a for a chosen platform. Either your NDK is not supported or is broken.")
+		endif()
+
+	endif()
 endif()
 
 
 # case of shared STL linkage
 if( ANDROID_STL MATCHES "shared" AND DEFINED __libstl )
- string( REPLACE "_static.a" "_shared.so" __libstl "${__libstl}" )
- # TODO: check if .so file exists before the renaming
+	string( REPLACE "_static.a" "_shared.so" __libstl "${__libstl}" )
+	# TODO: check if .so file exists before the renaming
 endif()
 
 
@@ -1235,21 +1190,22 @@ if( APPLE )
 endif()
 
 # Force set compilers because standard identification works badly for us
-include( CMakeForceCompiler )
-CMAKE_FORCE_C_COMPILER( "${CMAKE_C_COMPILER}" GNU )
 if( ANDROID_COMPILER_IS_CLANG )
  set( CMAKE_C_COMPILER_ID Clang)
 endif()
 set( CMAKE_C_PLATFORM_ID Linux )
-set( CMAKE_C_SIZEOF_DATA_PTR 4 )
+if( X86_64 OR MIPS64 OR ARM64_V8A )
+ set( CMAKE_C_SIZEOF_DATA_PTR 8 )
+else()
+ set( CMAKE_C_SIZEOF_DATA_PTR 4 )
+endif()
 set( CMAKE_C_HAS_ISYSROOT 1 )
 set( CMAKE_C_COMPILER_ABI ELF )
-CMAKE_FORCE_CXX_COMPILER( "${CMAKE_CXX_COMPILER}" GNU )
 if( ANDROID_COMPILER_IS_CLANG )
  set( CMAKE_CXX_COMPILER_ID Clang)
 endif()
 set( CMAKE_CXX_PLATFORM_ID Linux )
-set( CMAKE_CXX_SIZEOF_DATA_PTR 4 )
+set( CMAKE_CXX_SIZEOF_DATA_PTR ${CMAKE_C_SIZEOF_DATA_PTR} )
 set( CMAKE_CXX_HAS_ISYSROOT 1 )
 set( CMAKE_CXX_COMPILER_ABI ELF )
 set( CMAKE_CXX_SOURCE_FILE_EXTENSIONS cc cp cxx cpp CPP c++ C )
@@ -1290,7 +1246,14 @@ else()
 endif()
 
 # NDK flags
-if( ARMEABI OR ARMEABI_V7A )
+if (ARM64_V8A )
+ set( ANDROID_CXX_FLAGS         "${ANDROID_CXX_FLAGS} -fpic -ffunction-sections -funwind-tables" )
+ set( ANDROID_CXX_FLAGS_RELEASE "-fomit-frame-pointer -fstrict-aliasing" )
+ set( ANDROID_CXX_FLAGS_DEBUG   "-fno-omit-frame-pointer -fno-strict-aliasing" )
+ if( NOT ANDROID_COMPILER_IS_CLANG )
+  set( ANDROID_CXX_FLAGS_RELEASE "${ANDROID_CXX_FLAGS_RELEASE} -funswitch-loops -finline-limit=300" )
+ endif()
+elseif( ARMEABI OR ARMEABI_V7A)
  set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -fpic -funwind-tables" )
  if( NOT ANDROID_FORCE_ARM_BUILD AND NOT ARMEABI_V6 )
   set( ANDROID_CXX_FLAGS_RELEASE "-mthumb -fomit-frame-pointer -fno-strict-aliasing" )
@@ -1306,7 +1269,7 @@ if( ARMEABI OR ARMEABI_V7A )
    set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -funswitch-loops -finline-limit=300" )
   endif()
  endif()
-elseif( X86 )
+elseif( X86 OR X86_64 )
  set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -funwind-tables" )
  if( NOT ANDROID_COMPILER_IS_CLANG )
   set( ANDROID_CXX_FLAGS "${ANDROID_CXX_FLAGS} -funswitch-loops -finline-limit=300" )
@@ -1315,7 +1278,7 @@ elseif( X86 )
  endif()
  set( ANDROID_CXX_FLAGS_RELEASE "-fomit-frame-pointer -fstrict-aliasing" )
  set( ANDROID_CXX_FLAGS_DEBUG   "-fno-omit-frame-pointer -fno-strict-aliasing" )
-elseif( MIPS )
+elseif( MIPS OR MIPS64 )
  set( ANDROID_CXX_FLAGS         "${ANDROID_CXX_FLAGS} -fpic -fno-strict-aliasing -finline-functions -ffunction-sections -funwind-tables -fmessage-length=0" )
  set( ANDROID_CXX_FLAGS_RELEASE "-fomit-frame-pointer" )
  set( ANDROID_CXX_FLAGS_DEBUG   "-fno-omit-frame-pointer" )
@@ -1394,7 +1357,7 @@ if( EXISTS "${__libstl}" OR EXISTS "${__libsupcxx}" )
 endif()
 
 # variables controlling optional build flags
-if (ANDROID_NDK_RELEASE STRLESS "r7")
+if( ANDROID_NDK_RELEASE_NUM LESS 7000 ) # before r7
  # libGLESv2.so in NDK's prior to r7 refers to missing external symbols.
  # So this flag option is required for all projects using OpenGL from native.
  __INIT_VARIABLE( ANDROID_SO_UNDEFINED                      VALUES ON )
@@ -1410,7 +1373,7 @@ __INIT_VARIABLE( ANDROID_RELRO                              VALUES ON )
 set( ANDROID_NO_UNDEFINED           ${ANDROID_NO_UNDEFINED}           CACHE BOOL "Show all undefined symbols as linker errors" )
 set( ANDROID_SO_UNDEFINED           ${ANDROID_SO_UNDEFINED}           CACHE BOOL "Allows or disallows undefined symbols in shared libraries" )
 set( ANDROID_FUNCTION_LEVEL_LINKING ${ANDROID_FUNCTION_LEVEL_LINKING} CACHE BOOL "Allows or disallows undefined symbols in shared libraries" )
-set( ANDROID_GOLD_LINKER            ${ANDROID_GOLD_LINKER}            CACHE BOOL "Enables gold linker (only available for NDK r8b for ARM and x86 architectures on linux-86 and darwin-x86 hosts)" )
+set( ANDROID_GOLD_LINKER            ${ANDROID_GOLD_LINKER}            CACHE BOOL "Enables gold linker" )
 set( ANDROID_NOEXECSTACK            ${ANDROID_NOEXECSTACK}            CACHE BOOL "Allows or disallows undefined symbols in shared libraries" )
 set( ANDROID_RELRO                  ${ANDROID_RELRO}                  CACHE BOOL "Enables RELRO - a memory corruption mitigation technique" )
 mark_as_advanced( ANDROID_NO_UNDEFINED ANDROID_SO_UNDEFINED ANDROID_FUNCTION_LEVEL_LINKING ANDROID_GOLD_LINKER ANDROID_NOEXECSTACK ANDROID_RELRO )
@@ -1421,7 +1384,7 @@ set( ANDROID_LINKER_FLAGS "" )
 if( ARMEABI_V7A )
  # this is *required* to use the following linker flags that routes around
  # a CPU bug in some Cortex-A8 implementations:
- set( ANDROID_LINKER_FLAGS "${ANDROID_LINKER_FLAGS} -Wl,--fix-cortex-a8" )
+ set( ANDROID_LINKER_FLAGS "${ANDROID_LINKER_FLAGS} -march=armv7-a -Wl,--fix-cortex-a8" )
 endif()
 
 if( ANDROID_NO_UNDEFINED )
@@ -1445,9 +1408,9 @@ if( ANDROID_FUNCTION_LEVEL_LINKING )
 endif()
 
 if( ANDROID_COMPILER_VERSION VERSION_EQUAL "4.6" )
- if( ANDROID_GOLD_LINKER AND (CMAKE_HOST_UNIX OR ANDROID_NDK_RELEASE STRGREATER "r8b") AND (ARMEABI OR ARMEABI_V7A OR X86) )
+ if( ANDROID_GOLD_LINKER AND (CMAKE_HOST_UNIX OR ANDROID_NDK_RELEASE_NUM GREATER 8002) AND (ARMEABI OR ARMEABI_V7A OR X86) )
   set( ANDROID_LINKER_FLAGS "${ANDROID_LINKER_FLAGS} -fuse-ld=gold" )
- elseif( ANDROID_NDK_RELEASE STRGREATER "r8b")
+ elseif( ANDROID_NDK_RELEASE_NUM GREATER 8002 ) # after r8b
   set( ANDROID_LINKER_FLAGS "${ANDROID_LINKER_FLAGS} -fuse-ld=bfd" )
  elseif( ANDROID_NDK_RELEASE STREQUAL "r8b" AND ARMEABI AND NOT _CMAKE_IN_TRY_COMPILE )
   message( WARNING "The default bfd linker from arm GCC 4.6 toolchain can fail with 'unresolvable R_ARM_THM_CALL relocation' error message. See https://code.google.com/p/android/issues/detail?id=35342
@@ -1471,23 +1434,18 @@ if( ANDROID_RELRO )
 endif()
 
 if( ANDROID_COMPILER_IS_CLANG )
- set( ANDROID_CXX_FLAGS "-Qunused-arguments ${ANDROID_CXX_FLAGS}" )
- if( ARMEABI_V7A AND NOT ANDROID_FORCE_ARM_BUILD )
-  set( ANDROID_CXX_FLAGS_RELEASE "-target thumbv7-none-linux-androideabi ${ANDROID_CXX_FLAGS_RELEASE}" )
-  set( ANDROID_CXX_FLAGS_DEBUG   "-target ${ANDROID_LLVM_TRIPLE} ${ANDROID_CXX_FLAGS_DEBUG}" )
- else()
-  set( ANDROID_CXX_FLAGS "-target ${ANDROID_LLVM_TRIPLE} ${ANDROID_CXX_FLAGS}" )
- endif()
- if( BUILD_WITH_ANDROID_NDK )
-  set( ANDROID_CXX_FLAGS "-gcc-toolchain ${ANDROID_TOOLCHAIN_ROOT} ${ANDROID_CXX_FLAGS}" )
- endif()
+	set( ANDROID_CXX_FLAGS "-target ${ANDROID_LLVM_TRIPLE} -Qunused-arguments ${ANDROID_CXX_FLAGS}" )
+	if( BUILD_WITH_ANDROID_NDK )
+  		set( ANDROID_CXX_FLAGS "-gcc-toolchain ${ANDROID_TOOLCHAIN_ROOT} ${ANDROID_CXX_FLAGS}" )
+ 	endif()
 endif()
 
 # cache flags
 set( CMAKE_CXX_FLAGS           ""                        CACHE STRING "c++ flags" )
 set( CMAKE_C_FLAGS             ""                        CACHE STRING "c flags" )
-set( CMAKE_CXX_FLAGS_RELEASE   "-O3 -DNDEBUG"            CACHE STRING "c++ Release flags" )
-set( CMAKE_C_FLAGS_RELEASE     "-O3 -DNDEBUG"            CACHE STRING "c Release flags" )
+# Urho3D: optimise for size
+set( CMAKE_CXX_FLAGS_RELEASE   "-Os -DNDEBUG"            CACHE STRING "c++ Release flags" )
+set( CMAKE_C_FLAGS_RELEASE     "-Os -DNDEBUG"            CACHE STRING "c Release flags" )
 set( CMAKE_CXX_FLAGS_DEBUG     "-O0 -g -DDEBUG -D_DEBUG" CACHE STRING "c++ Debug flags" )
 set( CMAKE_C_FLAGS_DEBUG       "-O0 -g -DDEBUG -D_DEBUG" CACHE STRING "c Debug flags" )
 set( CMAKE_SHARED_LINKER_FLAGS ""                        CACHE STRING "shared linker flags" )
@@ -1580,7 +1538,7 @@ if( ANDROID_EXPLICIT_CRT_LINK )
 endif()
 
 # setup output directories
-set( LIBRARY_OUTPUT_PATH_ROOT ${CMAKE_BINARY_DIR} CACHE PATH "root for library output, set this to change where android libs are installed to" )
+set( LIBRARY_OUTPUT_DIRECTORY ${CMAKE_SOURCE_DIR} CACHE PATH "root for library output, set this to change where android libs are installed to" )
 set( CMAKE_INSTALL_PREFIX "${ANDROID_TOOLCHAIN_ROOT}/user" CACHE STRING "path for installing" )
 
 if(NOT _CMAKE_IN_TRY_COMPILE)
@@ -1589,18 +1547,19 @@ if(NOT _CMAKE_IN_TRY_COMPILE)
  else()
   set( EXECUTABLE_OUTPUT_PATH "${LIBRARY_OUTPUT_PATH_ROOT}/bin" CACHE PATH "Output directory for applications" )
  endif()
- set( LIBRARY_OUTPUT_PATH "${LIBRARY_OUTPUT_PATH_ROOT}/libs/${ANDROID_NDK_ABI_NAME}" CACHE PATH "path for android libs" )
+ # Urho3D: All libraries are first generated in CMake default binary directory and only the main target library is later copied to below output path by Urho3D own build script
+ set( ANDROID_LIBRARY_OUTPUT_PATH "${LIBRARY_OUTPUT_PATH_ROOT}/libs/${ANDROID_NDK_ABI_NAME}" CACHE PATH "path for android libs" FORCE )
 endif()
 
-# copy shaed stl library to build directory
+# copy shared stl library to build directory
 if( NOT _CMAKE_IN_TRY_COMPILE AND __libstl MATCHES "[.]so$" )
- get_filename_component( __libstlname "${__libstl}" NAME )
- execute_process( COMMAND "${CMAKE_COMMAND}" -E copy_if_different "${__libstl}" "${LIBRARY_OUTPUT_PATH}/${__libstlname}" RESULT_VARIABLE __fileCopyProcess )
- if( NOT __fileCopyProcess EQUAL 0 OR NOT EXISTS "${LIBRARY_OUTPUT_PATH}/${__libstlname}")
-  message( SEND_ERROR "Failed copying of ${__libstl} to the ${LIBRARY_OUTPUT_PATH}/${__libstlname}" )
- endif()
- unset( __fileCopyProcess )
- unset( __libstlname )
+	get_filename_component( __libstlname "${__libstl}" NAME )
+ 	execute_process( COMMAND "${CMAKE_COMMAND}" -E copy_if_different "${__libstl}" "${LIBRARY_OUTPUT_DIRECTORY}/${__libstlname}" RESULT_VARIABLE __fileCopyProcess )
+ 	if( NOT __fileCopyProcess EQUAL 0 OR NOT EXISTS "${LIBRARY_OUTPUT_DIRECTORY}/${__libstlname}")
+  		message( SEND_ERROR "Failed copying of ${__libstl} to the ${LIBRARY_OUTPUT_DIRECTORY}/${__libstlname}" )
+ 	endif()
+ 	unset( __fileCopyProcess )
+ 	unset( __libstlname )
 endif()
 
 
@@ -1700,15 +1659,14 @@ if( NOT PROJECT_NAME STREQUAL "CMAKE_TRY_COMPILE" )
                 ANDROID_EXPLICIT_CRT_LINK
                 )
   if( DEFINED ${__var} )
-   if( "${__var}" MATCHES " ")
+   if( ${__var} MATCHES " ")
     set( __toolchain_config "${__toolchain_config}set( ${__var} \"${${__var}}\" CACHE INTERNAL \"\" )\n" )
    else()
     set( __toolchain_config "${__toolchain_config}set( ${__var} ${${__var}} CACHE INTERNAL \"\" )\n" )
    endif()
   endif()
  endforeach()
- set( ANDROID_TOOLCHAIN_CONFIG_FILE "${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/android.toolchain.config.cmake" CACHE INTERNAL "" )
- file( WRITE "${ANDROID_TOOLCHAIN_CONFIG_FILE}" "${__toolchain_config}" )
+ file( WRITE "${CMAKE_BINARY_DIR}${CMAKE_FILES_DIRECTORY}/android.toolchain.config.cmake" "${__toolchain_config}" )
  unset( __toolchain_config )
 endif()
 
@@ -1737,8 +1695,8 @@ endif()
 
 
 # Variables controlling behavior or set by cmake toolchain:
-#   ANDROID_ABI : "armeabi-v7a" (default), "armeabi", "armeabi-v7a with NEON", "armeabi-v7a with VFPV3", "armeabi-v6 with VFP", "x86", "mips"
-#   ANDROID_NATIVE_API_LEVEL : 3,4,5,8,9,14 (depends on NDK version)
+#   ANDROID_ABI : "armeabi-v7a" (default), "armeabi", "armeabi-v7a with NEON", "armeabi-v7a with VFPV3", "armeabi-v6 with VFP", "x86", "mips", "arm64-v8a", "x86_64", "mips64"
+#   ANDROID_NATIVE_API_LEVEL : 3,4,5,8,9,14,15,16,17,18,19,21 (depends on NDK version)
 #   ANDROID_STL : gnustl_static/gnustl_shared/stlport_static/stlport_shared/gabi++_static/gabi++_shared/system_re/system/none
 #   ANDROID_FORBID_SYGWIN : ON/OFF
 #   ANDROID_NO_UNDEFINED : ON/OFF
@@ -1771,17 +1729,21 @@ endif()
 #   ARMEABI : TRUE for arm v6 and older devices
 #   ARMEABI_V6 : TRUE for arm v6
 #   ARMEABI_V7A : TRUE for arm v7a
+#   ARM64_V8A : TRUE for arm64-v8a
 #   NEON : TRUE if NEON unit is enabled
 #   VFPV3 : TRUE if VFP version 3 is enabled
 #   X86 : TRUE if configured for x86
+#   X86_64 : TRUE if configured for x86_64
 #   MIPS : TRUE if configured for mips
+#   MIPS64 : TRUE if configured for mips64
 #   BUILD_ANDROID : always TRUE
 #   BUILD_WITH_ANDROID_NDK : TRUE if NDK is used
 #   BUILD_WITH_STANDALONE_TOOLCHAIN : TRUE if standalone toolchain is used
 #   ANDROID_NDK_HOST_SYSTEM_NAME : "windows", "linux-x86" or "darwin-x86" depending on host platform
-#   ANDROID_NDK_ABI_NAME : "armeabi", "armeabi-v7a", "x86" or "mips" depending on ANDROID_ABI
-#   ANDROID_NDK_RELEASE : one of r5, r5b, r5c, r6, r6b, r7, r7b, r7c, r8, r8b, r8c, r8d, r8e, r9, r9b, r9c, r9d; set only for NDK
-#   ANDROID_ARCH_NAME : "arm" or "x86" or "mips" depending on ANDROID_ABI
+#   ANDROID_NDK_ABI_NAME : "armeabi", "armeabi-v7a", "x86", "mips", "arm64-v8a", "x86_64", "mips64" depending on ANDROID_ABI
+#   ANDROID_NDK_RELEASE : from r5 to r10c; set only for NDK
+#   ANDROID_NDK_RELEASE_NUM : numeric ANDROID_NDK_RELEASE version (1000*major+minor)
+#   ANDROID_ARCH_NAME : "arm", "x86", "mips", "arm64", "x86_64", "mips64" depending on ANDROID_ABI
 #   ANDROID_SYSROOT : path to the compiler sysroot
 #   TOOL_OS_SUFFIX : "" or ".exe" depending on host platform
 #   ANDROID_COMPILER_IS_CLANG : TRUE if clang compiler is used
@@ -1789,7 +1751,8 @@ endif()
 #   ARMEABI_NDK_NAME : superseded by ANDROID_NDK_ABI_NAME
 #
 # Secondary (less stable) read-only variables:
-#   ANDROID_COMPILER_VERSION : GCC version used
+#   ANDROID_COMPILER_VERSION : GCC version used (not Clang version)
+#   ANDROID_CLANG_VERSION : version of clang compiler if clang is used
 #   ANDROID_CXX_FLAGS : C/C++ compiler flags required by Android platform
 #   ANDROID_SUPPORTED_ABIS : list of currently allowed values for ANDROID_ABI
 #   ANDROID_TOOLCHAIN_MACHINE_NAME : "arm-linux-androideabi", "arm-eabi" or "i686-android-linux"
@@ -1800,7 +1763,6 @@ endif()
 #   ANDROID_RTTI : if rtti is enabled by the runtime
 #   ANDROID_EXCEPTIONS : if exceptions are enabled by the runtime
 #   ANDROID_GCC_TOOLCHAIN_NAME : read-only, differs from ANDROID_TOOLCHAIN_NAME only if clang is used
-#   ANDROID_CLANG_VERSION : version of clang compiler if clang is used
 #   ANDROID_LIBM_PATH : path to libm.so (set to something like $(TOP)/out/target/product/<product_name>/obj/lib/libm.so) to workaround unresolved `sincos`
 #
 # Defaults:
diff --git a/CMake/dcmtkUseAndroidSDK.cmake b/CMake/dcmtkUseAndroidSDK.cmake
index 925423e..866226a 100644
--- a/CMake/dcmtkUseAndroidSDK.cmake
+++ b/CMake/dcmtkUseAndroidSDK.cmake
@@ -261,12 +261,11 @@ FUNCTION(DCMTK_ANDROID_GET_EMULATOR_NAME VAR EMULATOR_UUID)
     WHILE(OFFLINE_EMULATORS)
         LIST(GET OFFLINE_EMULATORS 0 EMULATOR)
         LIST(REMOVE_AT OFFLINE_EMULATORS 0)
+        # When the device has connected adb wait-for-device will return 0
         EXECUTE_PROCESS(
             COMMAND ${ANDROID_ADB_PROGRAM} -s ${EMULATOR} wait-for-device
             TIMEOUT 1
             RESULT_VARIABLE RESULT
-            OUTPUT_QUIET
-            ERROR_QUIET
         )
         IF(NOT RESULT)
             DCMTK_ANDROID_GET_EMULATOR_UUID(${EMULATOR} UUID)
@@ -297,6 +296,7 @@ ENDFUNCTION()
 #
 FUNCTION(DCMTK_ANDROID_START_EMULATOR VAR)
     DCMTK_SETUP_ANDROID_EMULATOR()
+    MESSAGE(STATUS "Starting emulator named ${ANDROID_EMULATOR_AVD}")
     IF(NOT ANDROID_EMULATOR_AVD)
         MESSAGE(FATAL_ERROR "Please select which Android emulator Android Virtual Device (AVD) configuration to use!")
     ELSE()
@@ -322,17 +322,17 @@ FUNCTION(DCMTK_ANDROID_START_EMULATOR VAR)
             ENDIF()
             MESSAGE(STATUS "Found previously started Android device emulator, checking if it's still present... no")
         ENDIF()
+
         MESSAGE(STATUS "Starting the Android device emulator...")
         IF(CMAKE_HOST_SYSTEM MATCHES "Windows.*")
-            SET(COMMAND sh -c "${ANDROID_EMULATOR_PROGRAM} -avd ${ANDROID_EMULATOR_AVD} -no-boot-anim -noaudio -prop emu.uuid=${EMULATOR_UUID} >/dev/null 2>&1 < /dev/null &")
+            SET(COMMAND sh -c "${ANDROID_EMULATOR_PROGRAM} -avd ${ANDROID_EMULATOR_AVD} -no-boot-anim -prop emu.uuid=${EMULATOR_UUID} >/dev/null 2>&1 < /dev/null &")
         ELSE()
-            SET(COMMAND sh -c "${ANDROID_EMULATOR_PROGRAM} -avd ${ANDROID_EMULATOR_AVD} -no-window -no-boot-anim -noaudio -prop emu.uuid=${EMULATOR_UUID} >/dev/null 2>&1 < /dev/null &")
+            SET(COMMAND sh -c "${ANDROID_EMULATOR_PROGRAM} -avd ${ANDROID_EMULATOR_AVD} -no-window -no-boot-anim -prop emu.uuid=${EMULATOR_UUID} >/dev/null 2>&1 < /dev/null &")
         ENDIF()
+        MESSAGE(STATUS "${COMMAND}")
         EXECUTE_PROCESS(
             COMMAND ${COMMAND}
             RESULT_VARIABLE RESULT
-            OUTPUT_QUIET
-            ERROR_QUIET
         )
         IF(NOT RESULT)
             DCMTK_ANDROID_SET_OBJECT_PROPERTIES(${VAR} STARTING ${EMULATOR_UUID} "")
@@ -368,6 +368,17 @@ FUNCTION(DCMTK_ANDROID_WAIT_FOR_EMULATOR VAR)
             DCMTK_ANDROID_GET_EMULATOR_NAME(EMULATOR_NAME ${EMULATOR_UUID})
         ENDWHILE()
         DCMTK_ANDROID_SET_OBJECT_PROPERTIES(${VAR} RUNNING ${EMULATOR_UUID} ${EMULATOR_NAME})
+
+        MESSAGE(STATUS "Remounting filesystem read/write")
+        EXECUTE_PROCESS(
+            COMMAND ${ANDROID_ADB_PROGRAM} -s ${EMULATOR_NAME} shell mount -o rw,remount rootfs
+            RESULT_VARIABLE RESULT
+        )
+        MESSAGE(STATUS "Creating the temporary directory ${ANDROID_TEMPORARY_FILES_LOCATION}")
+        EXECUTE_PROCESS(
+            COMMAND ${ANDROID_ADB_PROGRAM} -s ${EMULATOR_NAME} shell mkdir ${ANDROID_TEMPORARY_FILES_LOCATION}
+            RESULT_VARIABLE RESULT
+        )
     ENDIF()
 ENDFUNCTION(DCMTK_ANDROID_WAIT_FOR_EMULATOR)
 
diff --git a/dcmdata/apps/img2dcm.cc b/dcmdata/apps/img2dcm.cc
index e547b5e..ede91d5 100644
--- a/dcmdata/apps/img2dcm.cc
+++ b/dcmdata/apps/img2dcm.cc
@@ -36,6 +36,10 @@
 #define OFFIS_CONSOLE_APPLICATION "img2dcm"
 static char rcsid[] = "$dcmtk: " OFFIS_CONSOLE_APPLICATION " v" OFFIS_DCMTK_VERSION " " OFFIS_DCMTK_RELEASEDATE " $";
 
+#if defined (HAVE_WINDOWS_H) || defined(HAVE_FNMATCH_H)
+#define PATTERN_MATCHING_AVAILABLE
+#endif
+
 #define SHORTCOL 4
 #define LONGCOL 21
 
@@ -110,6 +114,14 @@ static void addCmdLineOptions(OFCommandLine& cmd)
       cmd.addOption("--disable-ext",         "-de",     "disable support for extended sequential JPEG");
       cmd.addOption("--insist-on-jfif",      "-jf",     "insist on JFIF header");
       cmd.addOption("--keep-appn",           "-ka",     "keep APPn sections (except JFIF)");
+    cmd.addSubGroup("input files:");
+      cmd.addOption("--scan-directory",      "+sd",    "scan directory for input files (imgfile-in)");
+#ifdef PATTERN_MATCHING_AVAILABLE
+      cmd.addOption("--scan-pattern",        "+sp", 1, "[p]attern: string (only with --scan-directories)",
+                                                       "pattern for filename matching (wildcards)");
+#endif
+      cmd.addOption("--no-recurse",          "-r",     "do not recurse within directories (default)");
+      cmd.addOption("--recurse",             "+r",     "recurse within specified directories");
 
   cmd.addGroup("processing options:", LONGCOL, SHORTCOL + 2);
     cmd.addSubGroup("attribute checking:");
@@ -129,7 +141,7 @@ static void addCmdLineOptions(OFCommandLine& cmd)
   cmd.addGroup("output options:");
     cmd.addSubGroup("target SOP class:");
       cmd.addOption("--sec-capture",         "-sc",     "write Secondary Capture SOP class (default)");
-      cmd.addOption("--new-sc",              "-nsc",    "write new Secondary Capture SOP classes");
+      cmd.addOption("--new-sc",              "-nsc",    "write new Multiframe Secondary Capture SOP classes (default for multiframe)");
       cmd.addOption("--vl-photo",            "-vlp",    "write Visible Light Photographic SOP class");
 
     cmd.addSubGroup("output file format:");
@@ -155,7 +167,7 @@ static OFCondition startConversion(OFCommandLine& cmd,
 {
   // Parse command line and exclusive options
   prepareCmdLineArgs(argc, argv, OFFIS_CONSOLE_APPLICATION);
-  OFConsoleApplication app(OFFIS_CONSOLE_APPLICATION, "Convert standard image formats into DICOM format", rcsid);
+  OFConsoleApplication app(OFFIS_CONSOLE_APPLICATION, "Convert standard image formats into DICOM format. Supports multiframe creation.", rcsid);
   if (app.parseCommandLine(cmd, argc, argv))
   {
     /* check exclusive options first */
@@ -195,6 +207,13 @@ static OFCondition startConversion(OFCommandLine& cmd,
   // The transfer syntax proposed to be written by output plugin
   E_TransferSyntax writeXfer;
 
+  //input file options
+  OFBool    scanDir = OFFalse;
+  OFBool    recurse = OFFalse;
+  OFString  scanPattern = "";
+
+  //input file(s)
+  OFList<OFString> inputFiles;
   // Parse rest of command line options
   OFLog::configureFromCommandLine(cmd, app);
 
@@ -244,6 +263,37 @@ static OFCondition startConversion(OFCommandLine& cmd,
   }
   OFLOG_INFO(img2dcmLogger, OFFIS_CONSOLE_APPLICATION ": Instantiated input plugin: " << inputPlug->inputFormat());
 
+  if (cmd.findOption("--scan-directory")) scanDir = OFTrue;
+#ifdef PATTERN_MATCHING_AVAILABLE
+  if (cmd.findOption("--scan-pattern"))
+  {
+    app.checkDependence("--scan-pattern", "--scan-directory", scanDir);
+    app.checkValue(cmd.getValue(scanPattern));
+  }
+#endif
+  cmd.beginOptionBlock();
+  if (cmd.findOption("--no-recurse")) recurse = OFFalse;
+  if (cmd.findOption("--recurse"))
+  {
+    app.checkDependence("--recurse", "--scan-directories", scanDir);
+    recurse = OFTrue;
+  }
+  cmd.endOptionBlock();
+  
+  //scan for input files
+  if (scanDir)
+  {
+    //validate directory for beeing directory or file
+    if (!OFStandard::dirExists(pixDataFile))
+    {
+      OFLOG_ERROR(img2dcmLogger, "Directory input scanning option needs a folder as input");
+      return EC_IllegalCall;
+    }
+    OFStandard::searchDirectoryRecursively( pixDataFile, inputFiles, scanPattern, "", recurse );
+  }
+  else
+    inputFiles.push_front(pixDataFile);
+	
  // Find out which plugin to use
   cmd.beginOptionBlock();
   if (cmd.findOption("--sec-capture"))
@@ -256,7 +306,12 @@ static OFCondition startConversion(OFCommandLine& cmd,
     outPlug = new I2DOutputPlugNewSC();
   cmd.endOptionBlock();
   if (!outPlug) // default is the old Secondary Capture object
-    outPlug = new I2DOutputPlugSC();
+  {
+    if (scanDir) //default for multiframe input is new Multiframe Secondary Caputrue
+      outPlug = new I2DOutputPlugNewSC();
+    else
+      outPlug = new I2DOutputPlugSC();
+  }
   if (outPlug == NULL) return EC_MemoryExhausted;
   OFLOG_INFO(img2dcmLogger, OFFIS_CONSOLE_APPLICATION ": Instantiated output plugin: " << outPlug->ident());
 
@@ -368,7 +423,6 @@ static OFCondition startConversion(OFCommandLine& cmd,
     if ( cmd.findOption("--keep-appn") )
       jpgSource->setKeepAPPn(OFTrue);
   }
-  inputPlug->setImageFile(pixDataFile);
 
   /* make sure data dictionary is loaded */
   if (!dcmDataDict.isDictionaryLoaded())
diff --git a/dcmdata/include/dcmtk/dcmdata/libi2d/i2d.h b/dcmdata/include/dcmtk/dcmdata/libi2d/i2d.h
index cb1fb08..b1e9546 100644
--- a/dcmdata/include/dcmtk/dcmdata/libi2d/i2d.h
+++ b/dcmdata/include/dcmtk/dcmdata/libi2d/i2d.h
@@ -205,6 +205,29 @@ protected:
    OFString checkAndInventType2Attrib(const DcmTagKey& key,
                                       DcmDataset* targetDset) const;
 
+  /// If not empty, the DICOM file specified in this variable is used
+  /// as a base for the DICOM image file to be created, ie. all attributes
+  /// are taken over from this template file
+  OFString m_templateFile;
+
+  /// If true, patient and study data is read from file
+  OFBool m_readStudyLevel;
+
+  /// If true, patient, study and series data is read from file
+  OFBool m_readSeriesLevel;
+
+  /// If true, Instance Number ist read from file and incremented by 1
+  OFBool m_incInstNoFromFile;
+
+  /// If enabled, ISO_IR100 (ISO Latin 1) is inserted as a standard value
+  /// for attribute "Specific Character Set". Insertion takes place after
+  /// loading (optional) template file.
+  OFBool m_insertLatin1;
+
+  ///  If true, some simple attribute checks (missing type 2 attributes or
+  ///  missing type 1 values) are omitted
+  OFBool m_disableAttribChecks;
+
 private:
 
   /** Correctly inserts encapsulated pixel data.
@@ -225,27 +248,9 @@ private:
   /// (and are not checked by the isValid() function)
   OFList<OFString> m_overrideKeys;
 
-  /// If not empty, the DICOM file specified in this variable is used
-  /// as a base for the DICOM image file to be created, ie. all attributes
-  /// are taken over from this template file
-  OFString m_templateFile;
-
-  /// If true, patient and study data is read from file
-  OFBool m_readStudyLevel;
-
-  /// If true, patient, study and series data is read from file
-  OFBool m_readSeriesLevel;
-
   /// File to read study and series from
   OFString m_studySeriesFile;
 
-  /// If true, Instance Number ist read from file and incremented by 1
-  OFBool m_incInstNoFromFile;
-
-  ///  If true, some simple attribute checks (missing type 2 attributes or
-  ///  missing type 1 values) are omitted
-  OFBool m_disableAttribChecks;
-
   /// If true, missing type 2 elements are inserted automatically (empty value).
   /// Enabled per default.
   OFBool m_inventMissingType2Attribs;
@@ -253,11 +258,6 @@ private:
   /// If true, missing type 1 elements are inserted automatically with a
   /// predefined value, if possible. Disabled per default.
   OFBool m_inventMissingType1Attribs;
-
-  /// If enabled, ISO_IR100 (ISO Latin 1) is inserted as a standard value
-  /// for attribute "Specific Character Set". Insertion takes place after
-  /// loading (optional) template file.
-  OFBool m_insertLatin1;
 };
 
 #endif // I2D_H
diff --git a/dcmdata/include/dcmtk/dcmdata/libi2d/i2dbmps.h b/dcmdata/include/dcmtk/dcmdata/libi2d/i2dbmps.h
index 4db8479..17e7ee4 100644
--- a/dcmdata/include/dcmtk/dcmdata/libi2d/i2dbmps.h
+++ b/dcmdata/include/dcmtk/dcmdata/libi2d/i2dbmps.h
@@ -81,6 +81,20 @@ public:
                              Uint32& length,
                              E_TransferSyntax& ts);
 
+  /** Extracts the raw BMP pixel data stream from a BMP file and returns some
+   *  further information about this pixel data. Raw means that any header
+   *  information is removed from the BMP stream.
+   *  This function allocates memory for the pixel data returned to the user.
+   *  The caller of this function is responsible for deleting the memory buffer.
+   *  @param imgInfo - [out] Collection of Dicom Image Informations
+   *  @param pixData - [out] Pointer to the pixel data in BMP Interchange Format
+   *  @param length - [out] Length of pixel data
+   *  @return EC_Normal, if successful, error otherwise
+   */
+  OFCondition readPixelData( I2DImgDataInfo& imgInfo,
+                             char*&  pixData,
+                             Uint32& length);
+
   /** After reading of pixel data, this function can be used for getting
    *  information about lossy compression parameters.
    *  @param srcEncodingLossy - [out] Always returns OFFalse (i.e. lossless)
diff --git a/dcmdata/include/dcmtk/dcmdata/libi2d/i2dimgs.h b/dcmdata/include/dcmtk/dcmdata/libi2d/i2dimgs.h
index 83b3b55..b5ded39 100644
--- a/dcmdata/include/dcmtk/dcmdata/libi2d/i2dimgs.h
+++ b/dcmdata/include/dcmtk/dcmdata/libi2d/i2dimgs.h
@@ -29,6 +29,69 @@
 #include "dcmtk/dcmdata/dcxfer.h"
 #include "dcmtk/dcmdata/libi2d/i2define.h"
 
+struct I2DImgDataInfo
+{  
+  /** Helper structure for storing and comparing extracted pixel data image informations 
+   */
+
+  //Rows of image   
+  Uint16			rows;
+  //Columns of image
+  Uint16			cols;
+  //Number of components per pixel  
+  Uint16			samplesPerPixel;
+  //The DICOM color model used for the compressed data
+  OFString			photoMetrInt;
+  //Bits Allocated for one sample
+  Uint16			bitsAlloc;
+  //Bits Stored, number of bits stored within Bits Allocated
+  Uint16			bitsStored;
+  //High Bit, hightest bit position set within Bits Allocated
+  Uint16			highBit;
+  //Pixel Representation (0=unsigned, 1=signed)
+  Uint16			pixelRepr;
+  //Planar Configuration
+  Uint16			planConf;
+  //Horizontal value of pixel aspect ratio
+  Uint16			pixAspectH;
+  //Vertical value of pixel aspect ratio
+  Uint16			pixAspectV;
+
+  //The transfer syntax imposed by the imported pixel pixel data.
+  //This is necessary for the JPEG importer that needs to report
+  //which TS must be used for the imported JPEG data (ie. baseline, progressive, ...).
+  E_TransferSyntax	transSyn;
+
+  /** Compares if all members of both instances are equal
+   *  @param  other - [in] comparism instance
+   *  @return True if all member are identical, false otherwise
+   */
+  OFBool operator==(const I2DImgDataInfo& other)
+  {
+    return
+		(rows             == other.rows)				    &&
+		(cols				      == other.cols)				    &&
+		(samplesPerPixel	== other.samplesPerPixel)	&&
+		(photoMetrInt		  == other.photoMetrInt)		&&
+		(bitsAlloc			  == other.bitsAlloc)			  &&
+		(bitsStored			  == other.bitsStored)		  &&
+		(highBit			    == other.highBit)			    &&
+		(pixelRepr			  == other.pixelRepr)			  &&
+		(planConf			    == other.planConf)			  &&
+		(pixAspectH			  == other.pixAspectH)		  &&
+		(pixAspectV			  == other.pixAspectV)		  &&
+		(transSyn			    == other.transSyn);
+  };
+
+  OFBool operator!=(const I2DImgDataInfo& other)
+  {
+    return !(*this == other);
+  };
+
+
+};
+
+
 /** Base Class for plugins extracting pixel data from standard image files
  */
 class DCMTK_I2D_EXPORT I2DImgSource
@@ -80,6 +143,19 @@ public:
                                      Uint32& length,
                                      E_TransferSyntax& ts) =0;
 
+  /** Extracts the raw pixel data stream from image file and returns some further
+   *  information about this pixel data.
+   *  This function allocates memory for the pixel data returned to the user.
+   *  The caller of this function is responsible for deleting the memory buffer
+   *  @param imgInfo - [out] Collection of Dicom Image Informations
+   *  @param pixData - [out] Pointer to the pixel data
+   *  @param length - [out] Length of pixel data
+   *  @return EC_Normal, if successful, error otherwise
+   */
+  virtual OFCondition readPixelData( I2DImgDataInfo& imgInfo,
+                                     char*&  pixData,
+                                     Uint32& length) =0;
+
   /** After reading of pixel data, this function can be used for getting
    *  information about lossy compression parameters.
    *  @param srcEncodingLossy - [out] Denotes, whether the encoding of the pixel
diff --git a/dcmdata/include/dcmtk/dcmdata/libi2d/i2djpgs.h b/dcmdata/include/dcmtk/dcmdata/libi2d/i2djpgs.h
index 4e4d404..2838952 100644
--- a/dcmdata/include/dcmtk/dcmdata/libi2d/i2djpgs.h
+++ b/dcmdata/include/dcmtk/dcmdata/libi2d/i2djpgs.h
@@ -129,6 +129,22 @@ public:
                              Uint32& length,
                              E_TransferSyntax& ts);
 
+  /** Extracts the raw JPEG pixel data stream from a JPEG file and returns some
+   *  further information about this pixel data. Raw means here that all APP
+   *  markers (e.g. JFIF information) are removed from the JPEG stream.
+   *  The pixel data returned is a JPEG stream in JPEG interchange format.
+   *  This function allocates memory for the pixel data returned to the user.
+   *  The caller of this function is responsible for deleting the memory buffer.
+   *  @param imgInfo - [out] Collection of Dicom Image Informations
+   *  @param pixData - [out] Pointer to the pixel data in JPEG Interchange Format
+   *                         (but without APPx markers).
+   *  @param length - [out] Length of pixel data
+   *  @return EC_Normal, if successful, error otherwise
+   */
+  OFCondition readPixelData( I2DImgDataInfo& imgInfo,
+                             char*&  pixData,
+                             Uint32& length);
+
   /** After reading of pixel data, this function can be used for getting
    *  information about lossy compression parameters.
    *  @param srcEncodingLossy - [out] Denotes, whether the encoding of the pixel
diff --git a/dcmdata/libi2d/i2dbmps.cc b/dcmdata/libi2d/i2dbmps.cc
index 02a8836..887e167 100644
--- a/dcmdata/libi2d/i2dbmps.cc
+++ b/dcmdata/libi2d/i2dbmps.cc
@@ -146,6 +146,83 @@ OFCondition I2DBmpSource::readPixelData(Uint16& rows,
   return cond;
 }
 
+OFCondition I2DBmpSource::readPixelData(I2DImgDataInfo& imgInfo,
+                                        char*&  pixData,
+                                        Uint32& length)
+{
+  DCMDATA_LIBI2D_DEBUG("I2DBmpSource: Importing BMP pixel data");
+  OFCondition cond = openFile(m_imageFile);
+  // return error if file is not open
+  if (cond.bad())
+  {
+    closeFile();
+    return cond;
+  }
+
+  /* Read both file headers */
+  Uint32 dataOffset;
+  cond = readFileHeader(dataOffset);
+  if (cond.bad())
+  {
+    closeFile();
+    return cond;
+  }
+
+  Uint16 width, height;
+  Uint16 bpp, colors;
+  OFBool isTopDown = OFFalse; /* Most BMPs are stored bottom-up */
+  cond = readBitmapHeader(width, height, bpp, isTopDown, colors);
+  if (cond.bad())
+  {
+    closeFile();
+    return cond;
+  }
+
+  Uint32 *palette = NULL;
+  cond = readColorPalette(colors, palette);
+  if (cond.bad())
+  {
+    closeFile();
+    return cond;
+  }
+
+  /* Now jump to the bitmap data... */
+  if (bmpFile.fseek(dataOffset, SEEK_SET) != 0)
+  return EC_EndOfStream;
+
+  /* ...and read the "real" image data */
+  char *data;
+  Uint32 data_length;
+  cond = readBitmapData(width, height, bpp, isTopDown, colors, palette, data, data_length);
+
+  if (palette)
+  delete[] palette;
+
+  if (cond.bad())
+  {
+    closeFile();
+    return cond;
+  }
+
+  /* Now we got all the info that we need, return it to caller */
+
+  imgInfo.rows = height;
+  imgInfo.cols = width;
+  imgInfo.samplesPerPixel = 3;    /* 24 bpp */
+
+  imgInfo.bitsAlloc = 8;
+  imgInfo.bitsStored = 8;
+  imgInfo.highBit = 7;
+  imgInfo.photoMetrInt = "RGB";
+  imgInfo.planConf = 0;           /* For each pixel we save rgb in that order */
+  pixData = data;
+  length = data_length;
+  imgInfo.pixAspectH = imgInfo.pixAspectV = 1;
+  imgInfo.pixelRepr = 0;
+  imgInfo.transSyn = EXS_LittleEndianExplicit;
+
+  return cond;
+}
 
 OFCondition I2DBmpSource::readFileHeader(Uint32 &offset)
 {
diff --git a/dcmdata/libi2d/i2djpgs.cc b/dcmdata/libi2d/i2djpgs.cc
index bad687b..6684f40 100644
--- a/dcmdata/libi2d/i2djpgs.cc
+++ b/dcmdata/libi2d/i2djpgs.cc
@@ -229,6 +229,146 @@ OFCondition I2DJpegSource::readPixelData(Uint16& rows,
   return cond;
 }
 
+OFCondition I2DJpegSource::readPixelData(I2DImgDataInfo& imgInfo,
+                                         char*&  pixData,
+                                         Uint32& length)
+{
+  DCMDATA_LIBI2D_DEBUG("I2DJpegSource: Importing JPEG pixel data");
+  OFCondition cond = openFile(m_imageFile);
+  // return error if file is not open
+  if (cond.bad())
+  {
+    closeFile();
+    return cond;
+  }
+  // Create "map" with byte positions of all JPEG markers in JPEG file
+  cond = createJPEGFileMap();
+  if (cond.bad())
+  {
+    clearMap();
+    closeFile();
+    return cond;
+  }
+
+  // Check for image data in file (look for SOF marker)
+  E_JPGMARKER jpegEncoding;
+  OFListIterator(JPEGFileMapEntry*) entry = m_jpegFileMap.begin();
+  while (entry != m_jpegFileMap.end())
+  {
+    if ( isSOFMarker((*entry)->marker) )
+    {
+      jpegEncoding = OFstatic_cast(E_JPGMARKER, (*entry)->marker);
+      break;
+    }
+    entry++;
+  }
+  if (entry == m_jpegFileMap.end())
+  {
+    closeFile();
+    return makeOFCondition(OFM_dcmdata, 18, OF_error, "No image data found in JPEG file");
+  }
+
+  // Reject arithmetic and hierarchical (differential) encodings (not supported)
+  cond = isJPEGEncodingSupported(jpegEncoding);
+  if (cond.bad())
+  {
+    closeFile();
+    return cond;
+  }
+
+  // Get transfer syntax associated with the given JPEG encoding
+  imgInfo.transSyn = associatedTS(jpegEncoding);
+
+  // Extract width, height, samples per pixel, bits per sample
+  Uint16 width, height, spp, bps;
+  cond = getSOFImageParameters(**entry, width, height, spp, bps);
+  if (cond.bad())
+  {
+    closeFile();
+    return cond;
+  }
+
+  // Return error if invalid image attributes were found
+  if (height == 0 || width == 0)
+  {
+    closeFile();
+    return makeOFCondition(OFM_dcmdata, 18, OF_error, "Invalid image size (width or height = 0)");
+  }
+
+  // Examine JFIF information (version, horizontal and vertical aspect ratio, aspect ratio units.
+  Uint16 jfifVersion, unit;
+  Uint16 aspectH = 1;
+  Uint16 aspectV = 1;
+  entry = m_jpegFileMap.begin();
+  while (entry != m_jpegFileMap.end())
+  {
+    if ( (*entry)->marker == E_JPGMARKER_APP0 )
+    break;
+    entry++;
+  }
+  if ( entry == m_jpegFileMap.end())
+  {
+    if (!m_insistOnJFIF)
+    {
+      DCMDATA_LIBI2D_DEBUG("I2DJpegSource: Ignoring missing JFIF header");
+    }
+    else
+    {
+      closeFile();
+      return makeOFCondition(OFM_dcmdata, 18, OF_error, "No JFIF information found in JPEG file");
+    }
+  }
+  else
+  cond = getJFIFImageParameters(**entry, jfifVersion, aspectH, aspectV, unit);
+  if (cond.bad())
+  {
+    if (!m_insistOnJFIF)
+    {
+      DCMDATA_LIBI2D_DEBUG("I2DJpegSource: Ignoring errors while evaluating JFIF data");
+    }
+    else
+    {
+      closeFile();
+      return cond;
+    }
+  }
+  imgInfo.pixAspectH = aspectH;
+  imgInfo.pixAspectV = aspectV;
+
+  // Collect information needed for image pixel module
+  imgInfo.rows = height;
+  imgInfo.cols = width;
+  imgInfo.samplesPerPixel = spp;
+  imgInfo.bitsAlloc = bps;
+  imgInfo.bitsStored = imgInfo.bitsAlloc;
+  imgInfo.highBit = OFstatic_cast(Uint16, imgInfo.bitsStored - 1);
+  if (imgInfo.samplesPerPixel == 1)
+  imgInfo.photoMetrInt = "MONOCHROME2";
+  else if (imgInfo.samplesPerPixel == 3)
+  imgInfo.photoMetrInt = "YBR_FULL_422";
+  else
+  return makeOFCondition(OFM_dcmdata, 18, OF_error, "For JPEG data, Samples per Pixel must be 1 or 3");
+  // Planar Configuration and Pixel Representation is always 0 for JPEG data
+  imgInfo.planConf = 0;
+  imgInfo.pixelRepr = 0;
+
+  Uint32 tLength = 0;
+  char* tPixelData = NULL;
+  // Keep all APPx info (however, JFIF is always removed)
+  if (m_keepAPPn)
+  cond = copyJPEGStream(tPixelData, tLength);
+  // Cut off all APPx information from JPEG and get raw JPEG bit stream into memory
+  else
+  cond = extractRawJPEGStream(tPixelData, tLength);
+  if (cond.bad())
+  {
+    closeFile();
+    return cond;
+  }
+  length = tLength;
+  pixData = tPixelData;
+  return cond;
+}
 
 OFCondition I2DJpegSource::getLossyComprInfo(OFBool& srcEncodingLossy,
                                              OFString& srcLossyComprMethod) const
diff --git a/dcmdata/libi2d/i2dplnsc.cc b/dcmdata/libi2d/i2dplnsc.cc
index 72bb0f7..697e00d 100644
--- a/dcmdata/libi2d/i2dplnsc.cc
+++ b/dcmdata/libi2d/i2dplnsc.cc
@@ -95,8 +95,12 @@ OFCondition I2DOutputPlugNewSC::insertMultiFrameAttribs(DcmDataset* targetDatase
   if (!targetDataset)
     return EC_IllegalParameter;
 
-  // We only support 1 image Multi-frames so far
-  return targetDataset->putAndInsertOFStringArray(DCM_NumberOfFrames, "1");
+  //check for existing number of frames attribute - if not available add a 1-frame attribute
+  if (!targetDataset->tagExistsWithValue(DCM_NumberOfFrames))
+    return targetDataset->putAndInsertOFStringArray(DCM_NumberOfFrames, "1");
+  else
+    return EC_Normal;
+
   // Frame Increment pointer is set later in the more specific SC Multi-frame Image context
 }
 
